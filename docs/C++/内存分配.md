# 内存分配

![fds](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tZWRpYS5nZWVrc2ZvcmdlZWtzLm9yZy93cC1jb250ZW50L3VwbG9hZHMvbWVtb3J5TGF5b3V0Qy5qcGc?x-oss-process=image/format,png)
## 讲解
### Layout
- 1.stack

由编译器自动分配与释放，存放为运行时函数分配的局部automatic变量、函数参数、返回数据、返回地址等。其操作类似于数据结构中的栈。
As you do recursive calls, the stack is going downward.

- 2.memory mapping segment(映射区)

存储动态链接库等文件映射、申请大内存（malloc时调用mmap函数）
- 3.heap 

Begins at the end of the BSS segment and grows to larger addresses from there.
The Heap area is managed by `malloc`, `realloc`, and `free`.
When you do *malloc()* to allocate new things,the heap is going upward.
When we run out of memory, the heap and stack run into each other.

- 4.bss segment(block started by symbol)

*别名:Uninitialized data/`ZI` data(ZeroInitialie data)*
对于未初始化的全局变量和静态变量(全局and局部)，程序运行main之前时会统一清零。即未初始化的全局变量编译器会初始化为0
```cpp
//两种均是
static int i;
int j;
```
- 5.data segment

存储程序中已初始化的全局变量和静态变量(全局and局部)
进一步可分为`RO`(read-only area) and `RW`(read-write area)--字符串常量
```cpp
char s[] = “hello world”;//RW
debug=1 ;//RW 
const char* string = “hello world” ;
//“hello world”--RO ,character pointer variable string --RW
int main(){}
```
- 6.text segment

Placed below the heap or stack in order to prevent heaps and stack overflows from overwriting it.
有的立即数和指令编码放在.text中 
### 一个独立的概念(bss+data一部分)
>全局区(static)：也叫静态数据内存空间，存储全局变量和静态变量，全局变量和静态变量的存储是放一块的，初始化的全局变量和静态变量放一块区域，没有初始化的在相邻的另一块区域，程序结束后由系统释放。(不包含常量)

Thus,
`类的静态成员变量本质上是全局变量，哪怕一个对象都不存在，类的静态成员变量也存在`
`类的静态成员函数本质上是全局函数`
`只是其作用域为局部作用域`
## Example
```cpp
//main.cpp 程序代码区
int a = 0; //全局初始化区 
char *p1; //全局未初始化区 
main() 
{ 
    int b; //栈 
    char s[] = "abc"; //栈 
    char *p2; //栈 
    char *p3 = "123456"; //123456\0在常量区，p3在栈上。 
    static int c =0； //全局（静态）初始化区 
    p1 = (char *)malloc(10); 
    p2 = (char *)malloc(20); //分配得来得10和20字节的区域就在堆区。 
    strcpy(p1, "123456"); //123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。 
}
```