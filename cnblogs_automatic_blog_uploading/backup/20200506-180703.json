[
    {
        "dateCreated": "20200430T12:24:00",
        "description": "## Description\nWrite an algorithm to determine if a number n is \"happy\".\n\nA happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.\n\nReturn True if n is a happy number, and False if not.\n## \n>Input: 19\n\n>Output: true\n\n>Explanation: \n12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1\n\n## Analysis\n`\u5224\u65ad\u73af\u7684\u4e24\u5927\u65b9\u6cd5`\n\n### Hashset\n```cpp\nclass Solution {\npublic:\n    bool isHappy(int n) {\n        while(n!=1){\n            n=process(n);\n            if(a[n]==1)return 0;\n            a[n]=1;\n        }\n        return 1;\n    }\nprivate:\n    int process(int x){\n        int sum=0;\n        while(x!=0){\n            int u=x%10;\n            sum+=u*u;\n            x/=10;\n        }\n        return sum;\n    }\n    int a[50000];\n};\n```\n\n### \u9f9f\u5154\u8d5b\u8dd1\u6cd5\n![](https://assets.leetcode-cn.com/solution-static/202/1.jpg)\n*\u8bbe\u5b9a\u4e24\u4e2a\u6307\u9488\uff0c\u4e00\u5feb\u4e00\u6162\uff0c\u5feb\u7684\u4e00\u6b21\u8d702\u6b65\uff0c\u6162\u7684\u4e00\u6b21\u8d701\u6b65*\n## Code\n\n```cpp\nclass Solution {\npublic:\n    bool isHappy(int n) {\n        int a=n,b=n;\n        while(a!=1){\n            a=process(a);\n            a=process(a);\n            b=process(b);\n            if(a==b)break;\n        }\n        return a==1;\n    }\nprivate:\n    int process(int x){\n        int sum=0;\n        while(x!=0){\n            int u=x%10;\n            sum+=u*u;\n            x/=10;\n        }\n        return sum;\n    }\n};\n```",
        "title": "Leetcode202 Happy number",
        "categories": [
            "[\u968f\u7b14\u5206\u7c7b]Leetcode"
        ],
        "enclosure": {
            "length": 0
        },
        "link": "https://www.cnblogs.com/chanceYu/p/12808107.html",
        "permalink": "https://www.cnblogs.com/chanceYu/p/12808107.html",
        "postid": "12808107",
        "source": {},
        "userid": "-2"
    },
    {
        "dateCreated": "20200424T18:25:00",
        "description": "## \u6c47\u62a5\n### EE\n[\u81ea\u52a8\u5316\u672c\u7855](https://www.1point3acres.com/bbs/thread-611224-1-1.html)\n[\u4e1c\u5357EE](https://www.1point3acres.com/bbs/thread-605145-1-1.html)\n[\u6e05\u5317EE](https://www.1point3acres.com/bbs/thread-492062-1-1.html)\n[EEtop15](https://www.1point3acres.com/bbs/thread-585211-1-1.html)\n[\u6b66\u7406\u5317\u90ae\u901a\u4fe1](https://www.1point3acres.com/bbs/thread-615288-1-1.html)\n[EE\u8f6cCS\u7855\u7814\u4e00quit](https://www.1point3acres.com/bbs/thread-519021-1-1.html)\n[985EE](https://www.1point3acres.com/bbs/thread-352564-1-1.html)\n[\u540c\u6d4e\u6570\u5b66](https://www.1point3acres.com/bbs/home.php?mod=space&uid=267239&do=thread&type=thread&view=me&from=space)\n[\u5357\u5927\u7ea7EE](https://www.1point3acres.com/bbs/thread-367994-1-1.html)\n[\u590d\u65e6EE](https://www.1point3acres.com/bbs/thread-456448-1-1.html)\n[\u4e0a\u4ea4EE](https://www.1point3acres.com/bbs/thread-499961-1-1.html)\n**[\u4e2d\u79d1\u9662\u7ea7EE,\u4ea4\u6d41\u591a](https://www.1point3acres.com/bbs/thread-498766-1-1.html)**\n### CS\n~~[CS\u79d1\u73ed\u7814\u4e8cquit](https://www.1point3acres.com/bbs/thread-531509-1-1.html)~~\n~~[CS\u79d1\u73ed\u7814\u4e8cquit(another)](https://www.1point3acres.com/bbs/home.php?mod=space&uid=371295&do=thread&type=thread&view=me&from=space)~~\n[\u8f6f\u4ef6\u79d1\u73ed](https://www.1point3acres.com/bbs/thread-452365-1-1.html)\n[\u5317\u5927CS](https://www.1point3acres.com/bbs/home.php?mod=space&uid=416514&do=thread&type=thread&view=me&from=space)\n[\u540c\u6d4e\u8f6f\u4ef6](https://www.1point3acres.com/bbs/thread-188372-1-1.html)\n[CS\u79d1\u73ed](https://www.1point3acres.com/bbs/thread-369430-1-1.html)\n### \u5b9a\u4f4d\n[\u672c\u7855EE](https://www.1point3acres.com/bbs/thread-445880-1-1.html)\n## \u5206\u6790\n[\u5c0f\u7c73+\u5206\u6790](https://www.1point3acres.com/bbs/forum.php?mod=viewthread&tid=500718&page=1#pid6119501)\n[Top15EE\u7533\u8bf7\u603b\u7ed3](https://www.1point3acres.com/bbs/thread-425524-1-1.html)\n## \u9009\u6821\u603b\u7ed3\n|School  |program  |\n|--|--|\n|ASU | MCS SE|\n|CMU | ECE INI-MSIT-IS SE|\n|Cornell|ECE Meng|\n|Columbia|CE|\n|Duke  | ECE(+Meng) |\n|JHU  | CS |\n|NWU  | CE CS|\n|NEU  | MIS MSCS|\n|NYU Tandon|CS CE|\n |Rice  | MCS ECE|\n|TAMU  | CS MIS|\n|UCI  |MCS MSWE  |\n|UCB  |EECS Meng  |\n|UCSB|EE|\n|UCSD|ECE-EC79 CSME|\n|UCSC|MSCS|\n|UCD  |MSCS CE|\n|UTD  | CS |\n|USC  | CS37 CE|\n|UW|CS EE|\n|UMN  | MSCS|\n|VT  | CS|\n\n\n\n\n\n## \u7533\u8bf7\u603b\u7ed3\n[\u53ef\u63a5\u53d7\u6e05\u5355(\u5b58\u7591)](https://www.1point3acres.com/bbs/thread-395931-1-1.html)\n[ECE\u8f6c\u7801\u6821](https://www.1point3acres.com/bbs/thread-582240-1-1.html)\n[\u4e8c\u7855+\u5de5\u4f5c\u515a\u7533\u8bf7\u603b\u7ed3](https://www.1point3acres.com/bbs/thread-610671-1-1.html)",
        "title": "\u9009\u6821\u603b\u7ed3",
        "categories": [
            "[\u968f\u7b14\u5206\u7c7b]\u7559\u5b66"
        ],
        "enclosure": {
            "length": 0
        },
        "link": "https://www.cnblogs.com/chanceYu/p/12769289.html",
        "permalink": "https://www.cnblogs.com/chanceYu/p/12769289.html",
        "postid": "12769289",
        "source": {},
        "userid": "-2"
    },
    {
        "dateCreated": "20200423T22:28:00",
        "description": "## \u4e8c\u8fdb\u5236\u4e2d1\u7684\u4e2a\u6570\n[\u9898\u76ee\u94fe\u63a5](https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&tqId=11164&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)\n### \u6bcf\u4f4d\u904d\u5386O(n)\n```cpp\nclass Solution {\npublic:\n     int  NumberOf1(int n) {\n         unsigned int flag=1,sum=0;\n         for(int i=0;i<32;++i){\n             sum+=flag&n?1:0;\n             flag<<=1;\n         }\n         return sum;\n     }\n};\n```\n### \u53ea\u904d\u53861\u7684\u4e2a\u6570O(m)\n```cpp\nclass Solution {\npublic:\n     int  NumberOf1(int n) {\n         unsigned int sum=0;\n         while(n!=0){\n             n=n&(n-1);\n             sum++;\n         }\n         return sum;\n     }\n};\n```",
        "title": "\u4f4d\u8fd0\u7b97",
        "categories": [
            "[\u968f\u7b14\u5206\u7c7b]Leetcode"
        ],
        "enclosure": {
            "length": 0
        },
        "link": "https://www.cnblogs.com/chanceYu/p/12764174.html",
        "permalink": "https://www.cnblogs.com/chanceYu/p/12764174.html",
        "postid": "12764174",
        "source": {},
        "userid": "-2"
    },
    {
        "dateCreated": "20200414T23:24:00",
        "description": "### 01\u4e8c\u7ef4\u6570\u7ec4\u7684\u67e5\u627e\n```cpp\nclass Solution {\npublic:\n    bool Find(int target, vector<vector<int> > array) {\n        int n=array.size(),m=array[0].size();\n        int a=0,b=m-1;\n        while(a<n&&b>=0){\n            if(array[a][b]==target)return 1;\n            if(array[a][b]<target)a++;\n            else --b;\n        }\n        return 0;\n    }\n};\n```\n### 02\u66ff\u6362\u7a7a\u683c\n>\u5f00\u8f9f\u65b0\u5b58\u50a8\u7a7a\u95f4\n```cpp\nclass Solution {\npublic:\n    void replaceSpace(char *str,int length) {\n        string s=\"\";\n        for(int x=0;x<length;++x){\n            if(str[x]!=' ')s+=str[x];\n            else s+=\"%20\";\n        }\n        strcpy(str,s.c_str());\n    }\n};\n```\n>\u539f\u5b57\u7b26\u4e32\u4fee\u6539\n```cpp\nclass Solution {\npublic:\n\tvoid replaceSpace(char *str,int length) {\n            int len=0,j;\n            for(int i=0;i<length;++i)if(str[i]==' ')++len;\n            j=length+2*len-1;\n            for(int i=length-1;i>=0;--i){\n                if(str[i]==' '){\n                    str[j--]='0';str[j--]='2';str[j--]='%';\n                }else str[j--]=str[i];\n            }\n\t}\n};\n```\n### 03\u4ece\u5c3e\u5230\u5934\u53cd\u8f6c\u94fe\u8868\n>\u4e0d\u80fd\u6539\u53d8\u94fe\u8868\u7ed3\u6784\n```cpp\nclass Solution {\npublic:\n    vector<int> printListFromTailToHead(ListNode* head) {\n        stack<int>s;\n        vector<int>v;\n        for(auto p=head;p!=NULL;p=p->next)s.push(p->val);\n        while(!s.empty()){\n            v.push_back(s.top());\n            s.pop();\n        }\n        return v;\n    }\n};\n```\n>\u53ef\u4ee5\u6539\u53d8\n```cpp\nclass Solution {\npublic:\n    vector<int> printListFromTailToHead(ListNode* head) {\n        vector<int>v;\n        for(auto p=head;p!=NULL;p=p->next)v.push_back(p->val);\n        reverse(v.begin(),v.end());\n        return v;\n    }\n};\n```\n### 04\u91cd\u5efa\u4e8c\u53c9\u6811\n```cpp\nclass Solution {\npublic:\n    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {\n        p=pre,in=vin;\n        int n=pre.size();\n        TreeNode* t=build(0,n-1,0,n-1);\n        return t;\n    }\nprivate:\n    vector<int>p,in;\n    TreeNode* build(int prel,int prer,int inl,int inr){\n        if(prel>prer)return NULL;\n        TreeNode* t=new TreeNode(p[prel]);int i;\n        for(i=inl;i<=inr;++i)if(in[i]==p[prel])break;\n        t->left=build(prel+1,prel+i-inl,inl,i-1);\n        t->right=build(prel+i-inl+1,prer,i+1,inr);\n        return t;\n    }\n};\n```\n### 15 \u53cd\u8f6c\u94fe\u8868\n\u7b56\u7565:\u5728\u4f7f\u7528\u9012\u63a8\u524d\u4fdd\u5b58pnext\n```cpp\nclass Solution {\npublic:\n    ListNode* ReverseList(ListNode* pHead) {\n        ListNode* pnext=NULL;\n        ListNode* b=NULL;\n        for(auto p=pHead;p!=NULL;p=pnext){\n            pnext=p->next;\n            p->next=b;\n            b=p;\n        }\n        return b;\n    }\n};\n```",
        "title": "\u5251\u6307",
        "categories": [
            "[\u968f\u7b14\u5206\u7c7b]Leetcode"
        ],
        "enclosure": {
            "length": 0
        },
        "link": "https://www.cnblogs.com/chanceYu/p/12702197.html",
        "permalink": "https://www.cnblogs.com/chanceYu/p/12702197.html",
        "postid": "12702197",
        "source": {},
        "userid": "-2"
    },
    {
        "dateCreated": "20200219T16:26:00",
        "description": "# Google Tensorflow\u7ec3\u4e60\n## \u673a\u5668\u5b66\u4e60\u901f\u6210\u8bfe\u7a0b\u7ec3\u4e60\u4e2d\u7684\u5e38\u7528\u8d85\u53c2\u6570\n\n- steps\uff1a\u8bad\u7ec3\u8fed\u4ee3\u7684\u603b\u6b21\u6570\u3002\u4e00\u6b65\u8ba1\u7b97\u4e00\u6279\u6837\u672c\u4ea7\u751f\u7684\u635f\u5931\uff0c\u7136\u540e\u4f7f\u7528\u8be5\u503c\u4fee\u6539\u4e00\u6b21\u6a21\u578b\u7684\u6743\u91cd\u3002\n- batch size\uff1a\u5355\u6b65\u7684\u6837\u672c\u6570\u91cf\uff08\u968f\u673a\u9009\u62e9\uff09\u3002\u4f8b\u5982\uff0cSGD \u7684\u6279\u6b21\u5927\u5c0f\u4e3a 1\u3002\n\n>\u4ee5\u4e0b\u516c\u5f0f\u6210\u7acb:\n\ntotal_number_of_trained_examples=batch_size*steps\n  \n- periods\uff1a\u63a7\u5236\u62a5\u544a\u7684\u7c92\u5ea6\u3002\u4f8b\u5982\uff0c\u5982\u679c periods \u8bbe\u4e3a 7 \u4e14 steps \u8bbe\u4e3a 70\uff0c\u5219\u7ec3\u4e60\u5c06\u6bcf 10 \u6b65\u8f93\u51fa\u4e00\u6b21\u635f\u5931\u503c\uff08\u5373 7 \u6b21\uff09\u3002\u4e0e\u8d85\u53c2\u6570\u4e0d\u540c\uff0c\u6211\u4eec\u4e0d\u5e0c\u671b\u60a8\u4fee\u6539 periods \u7684\u503c\u3002\u8bf7\u6ce8\u610f\uff0c\u4fee\u6539 periods \u4e0d\u4f1a\u66f4\u6539\u6a21\u578b\u6240\u5b66\u4e60\u7684\u89c4\u5f8b\u3002\n\n>\u4ee5\u4e0b\u516c\u5f0f\u6210\u7acb\uff1a\n\nnumber_of_training_examples_in_each_period=batch_size*steps/periods\n# \u674e\u5b8f\u6bc52019\u673a\u5668\u5b66\u4e60hw1\n## Description\n\u672c\u6b21\u4f5c\u696d\u7684\u8cc7\u6599\u662f\u5f9e\u884c\u653f\u9662\u74b0\u5883\u74b0\u4fdd\u7f72\u7a7a\u6c23\u54c1\u8cea\u76e3\u6e2c\u7db2\u6240\u4e0b\u8f09\u7684\u89c0\u6e2c\u8cc7\u6599\u3002\n\u5e0c\u671b\u5927\u5bb6\u80fd\u5728\u672c\u4f5c\u696d\u5be6\u4f5c linear regression \u9810\u6e2c\u51faPM2.5\u7684\u6578\u503c\u3002\n\n\u672c\u6b21\u4f5c\u696d\u4f7f\u7528\u8c50\u539f\u7ad9\u7684\u89c0\u6e2c\u8a18\u9304\uff0c\u5206\u6210train set\u8ddftest set\uff0ctrain set\u662f\u8c50\u539f\u7ad9\u6bcf\u500b\u6708\u7684\u524d20\u5929\u6240\u6709\u8cc7\u6599\u3002test set\u5247\u662f\u5f9e\u8c50\u539f\u7ad9\u5269\u4e0b\u7684\u8cc7\u6599\u4e2d\u53d6\u6a23\u51fa\u4f86\u3002\n\n- train.csv: \u6bcf\u500b\u6708\u524d20\u5929\u7684\u5b8c\u6574\u8cc7\u6599\u3002\n- test.csv : \u5f9e\u5269\u4e0b\u7684\u8cc7\u6599\u7576\u4e2d\u53d6\u6a23\u51fa\u9023\u7e8c\u768410\u5c0f\u6642\u70ba\u4e00\u7b46\uff0c\u524d\u4e5d\u5c0f\u6642\u7684\u6240\u6709\u89c0\u6e2c\u6578\u64da\u7576\u4f5cfeature\uff0c\u7b2c\u5341\u5c0f\u6642\u7684PM2.5\u7576\u4f5canswer\u3002\n\n\u4e00\u5171\u53d6\u51fa240\u7b46\u4e0d\u91cd\u8907\u7684test data\uff0c\u8acb\u6839\u64dafeauure\u9810\u6e2c\u9019240\u7b46\u7684PM2.5\u3002\n## Code\n### \u7528heatmap\u5206\u6790PM2.5\u7684\u5f71\u54cd\u6210\u5206\n```py\n'''\n\u8bfb\u53d6\u6570\u636e,\u9884\u5904\u7406\n3600=3200 400\n'''\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\ntrain_data=pd.read_csv('train.csv',usecols=range(2,27))\ntrain_data=train_data.replace('NR',0)\ntrain_data=np.array(train_data)\nnew=np.empty((18,1))\nfor i in range(0,4320,18):\n    new=np.concatenate((new,train_data[i:i+18,1:]),axis=1)\nnew=new[:,1:].T\ntemp={}\nfor i in range(18):\n    temp[train_data[i,0]]=new[:,i]\nnew=pd.DataFrame(temp,dtype=float)\ncr=new.corr()\nsns.heatmap(cr,mask=cr<0.4)#,annot=True)\n```\n>notes:\n\n- *1.\u9884\u5904\u7406*\n- *2.\u6570\u7ec4\u7ef4\u5ea6\u4e00\u81f4\uff0c\u884c\u5217\u5411\u91cf\u7684\u8f6c\u6362*\n\n![heatmap](https://s2.ax1x.com/2020/02/20/3Z5ZDJ.jpg)\n### \u68af\u5ea6\u4e0b\u964d\u6cd5\n```py\n'''\n\u8bfb\u53d6\u6570\u636e,\u9884\u5904\u7406\n3600=3200 400\n'''\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\ntrain_data=pd.read_csv('E:/Git_Code/py/ml2019/train.csv',usecols=range(3,27))\ntrain_data=train_data.replace('NR',0)\ntrain_data=np.array(train_data)\ntrain_data=np.array(train_data).astype(float)\n'''\n\u521d\u6b65\u7ed3\u8bba:\nWS_HR,PM10,NO\n'''\nlr=0.01\nmy_feature,my_targets=[],[]\nfor i in range(0,4320,18):\n    for j in range(15):\n        # use_f=train_data[[i+4,i+8,i+17],j:j+9]\n        use_f=train_data[i+9,j:j+9]\n        use_t=train_data[i+9,j+9]\n        my_feature.append(use_f)\n        my_targets.append(use_t)\nmy_feature=np.array(my_feature)\nmy_targets=np.array(my_targets)\ntrain_f,test_f=my_feature[0:3300],my_feature[3300:]\ntrain_t,test_t=my_targets[0:3300],my_targets[3300:]\n'''\n\u66f4\u65b0\n'''\ndef update(feature,targets,steps):\n    #init\n    n=np.size(targets)#sample\n    b=0\n    b_diff=0\n    beta=0.012\n    m=np.size(feature,1)#input_feature\n    w=np.zeros(m)\n    w_diff=np.zeros(m)\n    print(\"sample:\",n,\"tait:\",m)\n    losses=[]\n    for x in range(steps):\n        loss=0\n        for i in range(m):\n            for j in range(n):\n                w_diff[i] -= feature[j,i]*(targets[j]-b-w.dot(feature[j,:]))\n            w_diff[i] += beta*w[i]\n            w_diff[i]/=n\n        for j in range(n):\n            b_diff-=targets[j]-b-w.dot(feature[j,:])\n            loss+=(targets[j]-b-w.dot(feature[j,:]))**2\n        b_diff/=n\n        loss+=np.sum(np.square(w))\n        loss/=n\n        losses.append(loss)\n        w_diff_2=np.sqrt(np.sum(w_diff*w_diff))\n        b_diff_2=np.sqrt(np.sum(b_diff*b_diff))\n        w-=lr*w_diff/w_diff_2\n        b-=lr*b_diff\n        ## count loss\n        if x%100==0:\n            print(\"after {} epochs,Loss is\".format(x),loss)\n    ## plot\n    plt.figure()\n    plt.plot(losses)\n    plt.xlabel(\"periods\")\n    plt.ylabel(\"Loss\")\n    plt.title(\"learing rate:{} beta:{}\".format(lr,beta))\ndef main():\n    update(train_f,train_t,700)\n    update(test_f,test_t,500)\n    plt.show()\nif __name__=='__main__':   \n    main()\n```\n#### Result\n\n![result](https://s2.ax1x.com/2020/02/20/3e656A.jpg)\n![result1](https://s2.ax1x.com/2020/02/20/3ecUBt.png)",
        "title": "\u673a\u5668\u5b66\u4e60\u4e4b\u68af\u5ea6\u4e0b\u964d\u6cd5",
        "categories": [
            "[\u968f\u7b14\u5206\u7c7b]\u673a\u5668\u5b66\u4e60",
            "[\u968f\u7b14\u5206\u7c7b]\u673a\u5668\u5b66\u4e60"
        ],
        "enclosure": {
            "length": 0
        },
        "link": "https://www.cnblogs.com/chanceYu/p/12331804.html",
        "permalink": "https://www.cnblogs.com/chanceYu/p/12331804.html",
        "postid": "12331804",
        "source": {},
        "userid": "-2"
    },
    {
        "dateCreated": "20200209T20:31:00",
        "description": "**\u7b2c 175 \u573a\u5468\u8d5b**\n## Description\nImplement the class TweetCounts that supports two methods:\n\n1. recordTweet(string tweetName, int time)\n\nStores the tweetName at the recorded time (in seconds).\n2. getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime)\n\nReturns the total number of occurrences for the given tweetName per minute, hour, or day (depending on freq) starting from the startTime (in seconds) and ending at the endTime (in seconds).\nfreq is always minute, hour or day, representing the time interval to get the total number of occurrences for the given tweetName.\nThe first time interval always starts from the startTime, so the time intervals are [startTime, startTime + delta*1>,  [startTime + delta*1, startTime + delta*2>, [startTime + delta*2, startTime + delta*3>, ... , [startTime + delta*i, min(startTime + delta*(i+1), endTime + 1)> for some non-negative number i and delta (which depends on freq).  \n## Constraints\nThere will be at most 10000 operations considering both recordTweet and getTweetCountsPerFrequency.\n- 0 <= time, startTime, endTime <= 10^9\n- 0 <= endTime - startTime <= 10^4\n\n## Example\n### Input\n[\"TweetCounts\",\"recordTweet\",\"recordTweet\",\"recordTweet\",\"getTweetCountsPerFrequency\",\"getTweetCountsPerFrequency\",\"recordTweet\",\"getTweetCountsPerFrequency\"]\n[[],[\"tweet3\",0],[\"tweet3\",60],[\"tweet3\",10],[\"minute\",\"tweet3\",0,59],[\"minute\",\"tweet3\",0,60],[\"tweet3\",120],[\"hour\",\"tweet3\",0,210]]\n\n### Output\n[null,null,null,null,[2],[2,1],null,[4]]\n\n### Explanation\n```java\nTweetCounts tweetCounts = new TweetCounts();\ntweetCounts.recordTweet(\"tweet3\", 0);\ntweetCounts.recordTweet(\"tweet3\", 60);\ntweetCounts.recordTweet(\"tweet3\", 10);                             // All tweets correspond to \"tweet3\" with recorded times at 0, 10 and 60.\ntweetCounts.getTweetCountsPerFrequency(\"minute\", \"tweet3\", 0, 59); // return [2]. The frequency is per minute (60 seconds), so there is one interval of time: 1) [0, 60> - > 2 tweets.\ntweetCounts.getTweetCountsPerFrequency(\"minute\", \"tweet3\", 0, 60); // return [2, 1]. The frequency is per minute (60 seconds), so there are two intervals of time: 1) [0, 60> - > 2 tweets, and 2) [60,61> - > 1 tweet.\ntweetCounts.recordTweet(\"tweet3\", 120);                            // All tweets correspond to \"tweet3\" with recorded times at 0, 10, 60 and 120.\ntweetCounts.getTweetCountsPerFrequency(\"hour\", \"tweet3\", 0, 210);  // return [4]. The frequency is per hour (3600 seconds), so there is one interval of time: 1) [0, 211> - > 4 tweets.\n```\n \n## Code\n\n```cpp\nclass TweetCounts {\npublic:\n    TweetCounts() {\n        t.clear();mp.clear();\n        t.resize(10);\n        r=0;\n    }\n    \n    void recordTweet(string tweetName, int time) {\n        if(mp[tweetName]==0){\n            mp[tweetName]=++r;\n        }\n        t[mp[tweetName]].push_back(time);\n    }\n    \n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\n        int f,i;\n        if(freq==\"minute\")f=60;\n        else if(freq==\"hour\")f=3600;\n        else if(freq==\"day\")f=24*3600;\n        vector<int>px((endTime-startTime)/f+1,0);\n        int index=mp[tweetName];\n        for(auto &u:t[index]){\n            if(u>endTime||u<startTime)continue;\n            else px[(u-startTime)/f]++;\n        }\n        return px;\n    }\nprivate:\n    vector<vector<int>> t;\n    unordered_map<string,int>mp;\n    int r;\n};\n```\n## Summary\n- unordered_map\u6613\u9519\u70b9:index\u548crecord_sum\u7684\u533a\u522b\n- \u600e\u4e48\u627e\u5faa\u73af-->\u6570\u7ec4\u662f\u5426\u53ef\u4ee5\u76f4\u63a5\u5b9a\u4f4d",
        "title": "leetcode1348 Tweet Counts Per Frequency",
        "categories": [
            "[\u968f\u7b14\u5206\u7c7b]Leetcode"
        ],
        "enclosure": {
            "length": 0
        },
        "link": "https://www.cnblogs.com/chanceYu/p/12288597.html",
        "permalink": "https://www.cnblogs.com/chanceYu/p/12288597.html",
        "postid": "12288597",
        "source": {},
        "userid": "-2"
    },
    {
        "dateCreated": "20200201T20:32:00",
        "description": "## Description\nBuilding and maintaining roads among communities in the far North is an expensive business. With this in mind, the roads are build such that there is only one route from a village to a village that does not pass through some other village twice. \nGiven is an area in the far North comprising a number of villages and roads among them such that any village can be reached by road from any other village. Your job is to find the road distance between the two most remote villages in the area. \n\nThe area has up to 10,000 villages connected by road segments. The villages are numbered from 1. \n## Input\n\nInput to the problem is a sequence of lines, each containing three positive integers: the number of a village, the number of a different village, and the length of the road segment connecting the villages in kilometers. All road segments are two-way.\n## Output\n\nYou are to output a single integer: the road distance between the two most remote villages in the area.\n## Sample Input\n\n5 1 6\n1 4 5\n6 3 9\n2 6 8\n6 1 7\n## Sample Output\n\n22\n## Analysis\n\u6811\u7684\u7ed3\u70b9\u5f80\u4e0a\u957f\u578bdp\nNote:\n- \u56fe\u7684\u90bb\u63a5\u8868\u6a21\u677f\n- \u5b57\u7b26\u4e32\u7684\u5904\u7406\n\n## Code\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint dp1[10001],dp2[10001],head[10001];\nint cnt=0,maxi=0;\nstruct edge{int v,w,next;}Edge[20001];\ninline void add_edge(int u,int v,int w){\n    Edge[++cnt]={v,w,head[u]};head[u]=cnt;\n}\nvoid dfs(int s,int pre){\n    for(int i=head[s];i;i=Edge[i].next){\n        int v=Edge[i].v;\n        if(v==pre)continue;dfs(v,s);\n        if(dp1[v]+Edge[i].w>dp1[s])dp2[s]=dp1[s],dp1[s]=dp1[v]+Edge[i].w;\n        else if(dp1[v]+Edge[i].w>dp2[s])dp2[s]=dp1[v]+Edge[i].w;\n    }maxi=max(maxi,dp1[s]+dp2[s]);\n}\nint main(){\n    int a,b,c,flag;char m[20];\n    while(1){\n        memset(head,-1,sizeof(head));memset(dp1,0,sizeof(dp1));\n        flag=cnt=maxi=0;memset(dp2,0,sizeof(dp2));\n        while(gets(m)!=NULL&&m[0]!='\\0'){\n            sscanf(m,\"%d%d%d\",&a,&b,&c);\n            add_edge(a,b,c),add_edge(b,a,c);flag=1;\n        }\n        if(flag==1){\n            dfs(1,0);\n            printf(\"%d\\n\",maxi);\n        }if(m[0]!='\\0')break;\n    }\n    return 0;\n}\n```",
        "title": "UVA10308 Roads in the North \u6811\u7684\u6700\u957f\u8def\u5f84",
        "categories": [
            "[\u968f\u7b14\u5206\u7c7b]\u7b97\u6cd5"
        ],
        "enclosure": {
            "length": 0
        },
        "link": "https://www.cnblogs.com/chanceYu/p/12250031.html",
        "permalink": "https://www.cnblogs.com/chanceYu/p/12250031.html",
        "postid": "12250031",
        "source": {},
        "userid": "-2"
    },
    {
        "dateCreated": "20200108T20:26:00",
        "description": "## Description\nPolygon is a game for one player that starts on a polygon with N vertices, like the one in Figure 1, where N=4. Each vertex is labelled with an integer and each edge is labelled with either the symbol + (addition) or the symbol * (product). The edges are numbered from 1 to N. \n![ava](https://vj.z180.cn/96cd7a6909cb9c42fa60d9c1028919a0?v=1578121841)\n\nOn the first move, one of the edges is removed. Subsequent moves involve the following steps: \n- pick an edge E and the two vertices V1 and V2 that are linked by E; and \n- replace them by a new vertex, labelled with the result of performing the operation indicated in E on the labels of V1 and V2. \nThe game ends when there are no more edges, and its score is the label of the single vertex remaining. \n\nConsider the polygon of Figure 1. The player started by removing edge 3. After that, the player picked edge 1, then edge 4, and, finally, edge 2. The score is 0. \n![av](https://vj.z180.cn/933a013acbbf63db8ad3aa17c03b8dd1?v=1578121841)\n\nWrite a program that, given a polygon, computes the highest possible score and lists all the edges that, if removed on the first move, can lead to a game with that score. \n## Instruction\n### Input\nYour program is to read from standard input. The input describes a polygon with N vertices. It contains two lines. On the first line is the number N. The second line contains the labels of edges 1, ..., N, interleaved with the vertices' labels (first that of the vertex between edges 1 and 2, then that of the vertex between edges 2 and 3, and so on, until that of the vertex between edges N and 1), all separated by one space. An edge label is either the letter t (representing +) or the letter x (representing *). \n\n3 <= N <= 50 \nFor any sequence of moves, vertex labels are in the range [-32768,32767]. \n### Output\nYour program is to write to standard output. On the first line your program must write the highest score one can get for the input polygon. On the second line it must write the list of all edges that, if removed on the first move, can lead to a game with that score. Edges must be written in increasing order, separated by one space.\n## Sample Input\n4\nt -7 t 4 x 2 x 5\n## Sample Output\n33\n1 2\n## Analysis\n\u6700\u5927\u503c\u9700\u8981\u52066\u79cd\u60c5\u51b5:++,--,+-,(+-)+,(+-)-\n\u76f8\u4e58\u6709maxmax,minmin,maxmin\u4e09\u79cd\n\u76f8\u52a0\u53ea\u6709maxmax\n## Code\n```cpp\n#include<algorithm>\n#include<set>\nusing namespace std;\nint dp[100][100],xp[100][100],c[100];\nset<int>v;\nint main(){\n    int n,i,j,x,sum=0;scanf(\"%d\\n\",&n);\n    for(i=n-1;i>=0;--i){\n        scanf(\"%c %d\",&c[i],&dp[i][i]);\n        c[i+n]=c[i];xp[i][i]=xp[i+n][i+n]=dp[i+n][i+n]=dp[i][i];\n        if(i!=0)getchar();\n    }\n    for(int z=1;z<n;++z)for(i=0;(j=i+z)<2*n;++i){\n    \txp[i][j]=5000000;dp[i][j]=-5000000;\n        for(int k=i;k<j;++k){\n            if(c[k]=='t'){\n                dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]);\n                xp[i][j]=min(xp[i][j],xp[i][k]+xp[k+1][j]);\n            }\n            else{\n                int y[5]={dp[i][j],dp[i][k]*dp[k+1][j],xp[i][k]*xp[k+1][j],dp[i][k]*xp[k+1][j],xp[i][k]*dp[k+1][j]};\n                dp[i][j]=*max_element(y,y+5);y[0]=xp[i][j];\n                xp[i][j]=*min_element(y,y+5);\n            }\n        }\n    }\n    for(i=0;i<n;++i){\n        x=(i==0)?1:(n+1-i);\n        if(dp[i][i+n-1]>sum){\n            v.clear();v.insert(x);sum=dp[i][i+n-1];\n        }\n        else if(dp[i][i+n-1]==sum)v.insert(x);\n    }\n    printf(\"%d\\n\",sum);\n    for(set<int>::iterator it=v.begin();it!=v.end();++it){\n        if(it!=v.begin())printf(\" \");\n        printf(\"%d\",*it);\n    }\n    return 0;\n}\n```",
        "title": "\u8d1f\u6570\u7684\u5904\u7406POJ1179Polygon",
        "categories": [
            "[\u968f\u7b14\u5206\u7c7b]\u7b97\u6cd5"
        ],
        "enclosure": {
            "length": 0
        },
        "link": "https://www.cnblogs.com/chanceYu/p/12168619.html",
        "permalink": "https://www.cnblogs.com/chanceYu/p/12168619.html",
        "postid": "12168619",
        "source": {},
        "userid": "-2"
    },
    {
        "dateCreated": "20200107T19:56:00",
        "description": "## Description\n\u5728\u4e00\u4e2a\u5706\u5f62\u64cd\u573a\u7684\u56db\u5468\u6446\u653e N \u5806\u77f3\u5b50,\u73b0\u8981\u5c06\u77f3\u5b50\u6709\u6b21\u5e8f\u5730\u5408\u5e76\u6210\u4e00\u5806.\u89c4\u5b9a\u6bcf\u6b21\u53ea\u80fd\u9009\u76f8\u90bb\u76842\u5806\u5408\u5e76\u6210\u65b0\u7684\u4e00\u5806\uff0c\u5e76\u5c06\u65b0\u7684\u4e00\u5806\u7684\u77f3\u5b50\u6570\uff0c\u8bb0\u4e3a\u8be5\u6b21\u5408\u5e76\u7684\u5f97\u5206\u3002\n\u8bd5\u8bbe\u8ba1\u51fa\u4e00\u4e2a\u7b97\u6cd5,\u8ba1\u7b97\u51fa\u5c06 N \u5806\u77f3\u5b50\u5408\u5e76\u6210 1\u5806\u7684\u6700\u5c0f\u5f97\u5206\u548c\u6700\u5927\u5f97\u5206\u3002\n\n\u6570\u636e\u7684\u7b2c 1 \u884c\u662f\u6b63\u6574\u6570 N\uff0c\u8868\u793a\u6709N\u5806\u77f3\u5b50\u3002\n\u7b2c 2 \u884c\u6709 N\u4e2a\u6574\u6570\uff0c\u7b2c i \u4e2a\u6574\u6570 $a_i$\u8868\u793a\u7b2c i \u5806\u77f3\u5b50\u7684\u4e2a\u6570\u3002\n\u8f93\u51fa\u5171 2 \u884c\uff0c\u7b2c 1 \u884c\u4e3a\u6700\u5c0f\u5f97\u5206\uff0c\u7b2c 2\u884c\u4e3a\u6700\u5927\u5f97\u5206\u3002\n## Input\n4\n4 5 9 4\n## Output\n43\n54\n## Analysis\n\u51b3\u7b56\u5bb9\u6613\u5206\u6790\uff0c\u6700\u4f18\u5b50\u7ed3\u6784\u6709\u4e24\u90e8\u5206\n\u65ad\u73af\u4e3a\u94fe\uff1a\u5c06\u957f\u5ea6\u4e3an\u7684\u94fe\u590d\u5236\u4e00\u4efd\u63a5\u5728\u540e\u9762\uff0c\u73af\u7684\u60c5\u51b5\u5c31\u662f\u957f\u5ea6\u4e3a2n\u7684\u94fe\u4e2d\u4efb\u610f\u8fde\u7eed\u7684\u957f\u5ea6\u4e3an\u7684\u94fe\u3002\n## Code\n### \u6211\u7684\u5199\u6cd5\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint s[101],a[100],xp[100][100],dp[100][100];\nint main(){\n    int n,i,j,maxi=0,mini=200000;scanf(\"%d\",&n);\n    for(i=0;i<n;++i){\n        scanf(\"%d\",&a[i]);\n        s[i+1]=s[i]+a[i];s[i+1+n]=s[i+1];\n    }\n    for(i=0;i<n;++i)s[i+1+n]+=s[n];\n    for(int z=1;z<n;++z)for(i=0;i<n;++i){        \n        j=i+z;xp[i][j%n]=200000;\n        for(int k=i;k<j;++k){\n            xp[i][j%n]=min(xp[i][j%n],xp[i][k%n]+xp[(k+1)%n][j%n]+s[j+1]-s[i]);\n            dp[i][j%n]=max(dp[i][j%n],dp[i][k%n]+dp[(k+1)%n][j%n]+s[j+1]-s[i]);\n            if(z==n-1)mini=min(mini,xp[i][j%n]);\n            if(z==n-1)maxi=max(maxi,dp[i][j%n]);\n        }\n    }\n    printf(\"%d\\n%d\",mini,maxi);\n    return 0;\n}\n```\n### \u53e6\u4e00\u79cd\u5199\u6cd5\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,l,anss,ansb,a[110],sum[210],dp[210][210],dpbig[210][210];\nint main(){\n\tmemset(dp,0x3f,sizeof(dp)); anss=dp[0][0];\n\tcin>>n;\n\tfor (int i=1;i<=n;i++) cin>>a[i]; a[0]=a[n];\n\tfor (int i=1;i<=2*n;i++){\n\t\tsum[i]=sum[i-1]+a[i%n];\n\t\tdp[i][i]=0;\n\t}\n\tfor (int len=2;len<=n;len++){\n\t\tfor (int r=len;r<=2*n;r++){\n\t\t\tl=r-len+1;\n\t\t\tfor (int j=l;j<r;j++){\n\t\t\t\tdp[l][r]=min(dp[l][j]+dp[j+1][r]+sum[r]-sum[l-1],dp[l][r]);\n\t\t\t\tdpbig[l][r]=max(dpbig[l][j]+dpbig[j+1][r]+sum[r]-sum[l-1],dpbig[l][r]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tanss=min(dp[i][i+n-1],anss);\n\t\tansb=max(dpbig[i][i+n-1],ansb);\n\t}\n\tcout<<anss<<endl;\n\tcout<<ansb;\n\treturn 0;\n}\n```",
        "title": "\u73af\u5f62\u7684\u5904\u7406P1880 [NOI1995]\u77f3\u5b50\u5408\u5e76",
        "categories": [
            "[\u968f\u7b14\u5206\u7c7b]\u7b97\u6cd5"
        ],
        "enclosure": {
            "length": 0
        },
        "link": "https://www.cnblogs.com/chanceYu/p/12163451.html",
        "permalink": "https://www.cnblogs.com/chanceYu/p/12163451.html",
        "postid": "12163451",
        "source": {},
        "userid": "-2"
    },
    {
        "dateCreated": "20200104T20:37:00",
        "description": "## Despription\nTriangulation of surfaces has applications in the Finite Element Method of solid mechanics. The objective is to estimate the stress and strain on complex objects by partitioning them into small simple objects which are considered incompressible. It is convenient to approximate a plane surface with a simple polygon, i.e., a piecewise-linear, closed curve in the plane on m distinct vertices, which does not intersect itself. A chord is a line segment between two non-adjacent vertices of the polygon which lies entirely inside the polygon, so in particular, the endpoints of the chord are the only points of the chord that touch the boundary of the polygon. A triangulation of the polygon, is any choice of m - 3 chords, such that the polygon is divided into triangles. In a triangulation, no two of the chosen chords intersect each other, except at endpoints, and all of the remaining (unchosen) chords cross at least one of the chosen chords. Fortunately, finding an arbitrary triangulation is a fairly easy task, but what if you were asked to find the best triangulation according to some measure?\n![avatar](https://images.ptausercontent.com/0000%2F2227%2Fi.gif)\nFigure 1: Five out of nine possible triangulations of the example polygon. The leftmost has the smallest largest triangle.\n## Instructions\n### Input\nOn the first line of the input is a single positive integer n, telling the number of test scenarios to follow. Each scenario begins with a line containing one positive integer 2 < m < 50, being the number of vertices of the simple polygon. The following m lines contain the vertices of the polygon in the order they appear along the border, going either clockwise or counter clockwise, starting at an arbitrary vertex. Each vertex is described by a pair of integers x y obeying 0 <= x <= 10 000 and 0 <= y <= 10 000.\n### Output\nFor each scenario, output one line containing the area of the largest triangle in the triangulation of the polygon which has the smallest largest triangle. The area should be presented with one fractional decimal digit.\n## Sample Input\n1\n6\n7 0\n6 2\n9 5\n3 5\n0 3\n1 1\n\n## Sample Output\n9.0\n## Analysis\n\u5b50\u7ed3\u6784\u662f\u6bcf\u6b21\u9009\u53d6\u4e00\u4e2a\u70b9\uff0c\u5206\u6210\u4e24\u5757\u548c\u4e00\u4e2a\u4e09\u89d2\u5f62\uff0c\u7136\u540e\u627e\u4e09\u8005\u6700\u5927\u503c\uff0c\u591a\u6b21\u53d6\u70b9\u53d6\u6700\u5c0f\u503c\n\u4e09\u8005\u6bd4\u8f83\u8868\u8fbe\u65b9\u5f0fmax(a,max(b,c))\n### Code\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nstruct Node{\n    int x,y;\n}node[50];\nint dp[50][50];\ninline int S(Node& i,Node& k,Node& j){return abs(k.y*j.x-i.y*j.x-k.y*i.x-k.x*j.y+i.x*j.y+k.x*i.y);}\nbool check(int &i,int &k,int &j,int &m){\n    for(int r=0;r<m;++r)if(r==i||r==k||r==j)continue;\n    else if(S(node[i],node[k],node[r])+S(node[i],node[j],node[r])+S(node[k],node[j],node[r])\n==S(node[i],node[j],node[k]))return 0;\n    return 1;\n}\nint main(){\n    int n,i,j,m,k;scanf(\"%d\",&n);\n    for(int sq=0;sq<n;++sq){\n        scanf(\"%d\",&m);\n        for(i=0;i<m;++i)scanf(\"%d%d\",&node[i].x,&node[i].y);\n        for(int z=2;z<m;++z)for(i=0;(j=i+z)<m;++i){\n        \tdp[i][j]=70000000;\n        \tfor(k=i+1;k<j;++k){\n                if(!check(i,j,k,m))continue;\n\t            int t[3]={dp[i][k],dp[k][j],S(node[i],node[k],node[j])};\n\t            dp[i][j]=min(dp[i][j],*max_element(t,t+3));\n        \t}\n\t\t}\n        printf(\"%.1f\\n\",dp[0][m-1]/2.0);\n    }\n    return 0;\n}\n```",
        "title": "ZOJ2227Minimax\u4e09\u89d2\u5212\u5206",
        "categories": [
            "[\u968f\u7b14\u5206\u7c7b]\u7b97\u6cd5"
        ],
        "enclosure": {
            "length": 0
        },
        "link": "https://www.cnblogs.com/chanceYu/p/12150325.html",
        "permalink": "https://www.cnblogs.com/chanceYu/p/12150325.html",
        "postid": "12150325",
        "source": {},
        "userid": "-2"
    },
    {
        "dateCreated": "20191230T19:49:00",
        "description": "## Description\nYou are given the task to design a lighting system for a huge conference hall. After doing a lot of calculation & sketching, you have figured out the requirements for an energy-efficient design that can properly illuminate the entire hall. According to your design, you need lamps of n different power ratings. For some strange current regulation method, all the lamps need to be fed with the same amount of current. So, each category of lamp has a corresponding voltage rating. Now, you know the number of lamps & cost of every single unit of lamp for each category. But the problem is, you are to buy equivalent voltage sources for all the lamp categories. You can buy a single voltage source for each category (Each source is capable of supplying to infinite number of lamps of its voltage rating.) & complete the design. But the accounts section of your company soon figures out that they might be able to reduce the total system cost by eliminating some of the voltage sources & replacing the lamps of that category with higher rating lamps. Certainly you can never replace a lamp by a lower rating lamp as some portion of the hall might not be illuminated then. You are more concerned about money-saving than energy-saving. Find the minimum possible cost to design the system.\n## Input Instruction\nEach case in the input begins with n (1<=n<=1000), denoting the number of categories. Each of the following n lines describes a category. A category is described by 4 integers - V (1<=V<=132000), the voltage rating, K (1<=K<=1000), the cost of a voltage source of this rating, C (1<=C<=10), the cost of a lamp of this rating & L (1<=L<=100), the number of lamps required in this category. The input terminates with a test case where n = 0. This case should not be processed.\n## Output Instruction\nFor each test case, print the minimum possible cost to design the system.\n### Sample Input\n3\n\n100 500 10 20\n\n120 600 8 16\n\n220 400 7 18\n\n0\n### Sample Output\n778\n## Analysis\n\u5fc5\u987b\u6d88\u9664\u5c40\u90e8\u6700\u4f18\uff0c\u8003\u8651\u706f\u6ce1\u53d8\u6362\u5206\u4e3a\u51e0\u4e2a\u70b9\uff0c\u5b9a\u4e49dp[i]\u4e3a1-i-1\u706f\u6ce1\u4e2d\u82e5\u5e72\u706f\u6ce1\u7528ai\u66ff\u6362\uff0c\u90a3\u4e48\u8fd8\u6709\u524d\u9762\u7684\u4e00\u4e9b\u66ff\u6362\u706f\u6ce1\n\u4e0b\u8bc1\u82e5\u706f\u6ce1j\u88abi\u66ff\u6362\uff0cj-i-1\u5747\u88abi\u66ff\u6362\n\u2235\u706f\u6ce1j\u88abi\u66ff\u6362\n\n\u2234(l[i]-l[j])*c[j]-k[j]<0\n\n\u53c8\u2235\u706f\u6ce1j\u4e0d\u80fd\u88abj+1\u66ff\u6362\n\n\u2234(l[j+1]-l[j])*c[j]-k[j]>(l[i]-l[j])*c[j]-k[j]\n\n\u2234l[j+1]< l[i]\n\n\u2234(l[i]-l[j+1])*c[j+1]-k[j+1]<0\n\n\u2234\u706f\u6ce1j+1\u80fd\u88abi\u66ff\u6362\n\u53ef\u5f97\u51fa\u9012\u63a8\u516c\u5f0fdp[i]=min{dp[j]+(s[i]-s[j])*c[i]+k[i]}\n## Code\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nstruct Node{\n    int v,k,c,l;\n}node[1001];\nint dp[1005],s[1001];\ninline bool cmp(Node a,Node b){return a.v<b.v;}\nint main(){\n    int n,i,j,x;\n\twhile(~scanf(\"%d\",&n),n){\n\t\tdp[0]=s[0]=0;\n        for(i=1;i<=n;++i)\n            scanf(\"%d%d%d%d\",&node[i].v,&node[i].k,&node[i].c,&node[i].l);\n        sort(node+1,node+n+1,cmp);\n        for(i=1;i<=n;++i){\n            s[i]=s[i-1]+node[i].l;dp[i]=10000000;\n            for(j=0;j<i;++j)\n            dp[i]=min(dp[i],dp[j]+(s[i]-s[j])*node[i].c +node[i].k);\n        }\n        printf(\"%d\\n\",dp[n]);\n    }\n    return 0;\n}\n```",
        "title": "UVA11400 Lighting System Design",
        "categories": [
            "[\u968f\u7b14\u5206\u7c7b]\u7b97\u6cd5"
        ],
        "enclosure": {
            "length": 0
        },
        "link": "https://www.cnblogs.com/chanceYu/p/12121425.html",
        "permalink": "https://www.cnblogs.com/chanceYu/p/12121425.html",
        "postid": "12121425",
        "source": {},
        "userid": "-2"
    },
    {
        "dateCreated": "20191228T17:09:00",
        "description": "## \u5355\u6a21\u5339\u914d--KMP\n\u5b9a\u4e49\u4e24\u4e2a\u5b57\u7b26\u4e32text\u548cpattern,pattern\u4e0d\u65ad\u4f4d\u79fb\u7684\u8fc7\u7a0b\u4e2d,\u9700\u8981\u8ba9\u5176\u4e2d\u95f4\u65ad\u6389\u7684\u65f6\u5019\u526a\u679d\n\nEg:*ABAABAB*\n### \u5efanext\u6570\u7ec4-->\u6700\u957f\u76f8\u7b49\u524d\u540e\u7f00[0...k] [i-k...i]\ni:0->pattern.length()-1,j=-1\n- case1:p[j+1]=p[i]-->j++;\n- case2:\u4e0a\u4e00\u4e2a\u5143\u7d20\u5185\u62c6\u524d\u540e\u7f00\nwhile(j!=-1&&p[i]!=p[j+1])j=next[j];\np[j+1]=p[i]-->j++;\n\n`\u72b6\u6001\u8f6c\u79fb:next[i]=j;`\n\n### \u79fb\u4f4d\u5339\u914d\ni:0->text.length()-1,j=-1\n- case1:p[j+1]=t[i]-->j++;\n- case2:\u4e0a\u4e00\u4e2a\u5143\u7d20\u5185\u62c6\u524d\u540e\u7f00\nwhile(j!=-1&&t[i]!=p[j+1])j=next[j];\np[j+1]=t[i]-->j++;\n\n\u5224\u65ad\uff1aj==m-1-->return true\n\n### \u4ee3\u7801\u6a21\u677f\n```cpp\nscanf(\"%s%s\",s1,s2);int a=strlen(s1);//text\nint b=strlen(s2);//pattern\nnxt[0]=-1;\nfor(i=1;i<b;++i){\n    while(j!=-1&&s2[j+1]!=s2[i])j=nxt[j];\n    if(s2[j+1]==s2[i])++j;\n    nxt[i]=j;\n}j=-1;\nfor(i=0;i<a;++i){\n    while(j!=-1&&s2[j+1]!=s1[i])j=nxt[j];\n    if(s2[j+1]==s1[i])++j;\n    if(j==b-1)printf(\"%d\\n\",i-b+2);\n}\n```\n## \u591a\u6a21\u5339\u914d--AC\u81ea\u52a8\u673a\n\u5b9a\u4e49text\u548cpattern,pattern1\u5728\u67d0\u4f4dfail\u65f6\u53ef\u4ee5\u4ece\u8be5\u4f4dfail\u60f3\u529e\u6cd5\u526a\u679d\n\n### \u5efafail\u6570\u7ec4\n\u6839\u636efail\u6765\u6e90\u5efa\u8868\u987a\u5e8f\u53ef\u4ee5\u662fBFS,\u6307\u5411\u4e3a\u4e86\u8fdb\u884c\u4e0b\u4e00\u4e2a\u6a21\u677f,fail\u4e3a\u4e86\u8bb0\u5f55\u8df3\u8f6c\u7684\u8d77\u70b9\n\n\u6bcf\u53d6\u4e00\u4e2au,i:26capital\n- case1:e[u][i]!=0`\u56de\u52300\u6216\u8005\u4e0a\u4e00\u4e2afail\u4e0b\u9762p`\n#### fail[e[u][i]]=e[fail[u]][i];\n- case2:e[u][i]=0\u6307\u5411\u4e0a\u4e00\u4e2afail\u4e0b\u9762p\n#### e[u][i]=e[fail[u]][i];\n\n### \u63d2\u5165trie\ni:pattern,j=0\n- case1:e[j][i]=0->e[j][i]=++cnt(\u603b\u5e8f\u53f7);\n- case2:e[j][i]!=0\n\n\u5224\u65ad:val[pattern.length()-1]=1;\n\n`\u72b6\u6001\u8f6c\u79fb:j=e[j][i]`\n\n### query\n\n\u662f\u5426\u5141\u8bb8\u4e32\u91cd\u590d\u51fa\u73b0-->\u662f\u5426\u8bbe\u7f6eval[]=-1\n\ni:text\n\n\u53bb\u91cd\u5904\u7406t=j,while(t)fail[t]=-1,t=fail[t];\n- case1:val[j]!=-1->sum+=val[j];\n- case2:val[j]=-1\n\n`\u72b6\u6001\u8f6c\u79fb:j=e[j][i]`\n\n### \u4ee3\u7801\n```cpp\nstruct AC{\n    int fail[500010],val[500010],e[500010][26],cnt=0;\n    void ins(char* p){\n        int len=strlen(p);int j=0;\n        for(int i=0;i<len;++i){\n            int x=p[i]-'a';\n            if(e[j][x]==0)e[j][x]=++cnt;\n            j=e[j][x];\n        }\n        val[j]++;\n    }\n    void build(){\n        for(int i=0;i<26;++i)if(e[0][i])fail[e[0][i]]=0,q.push(e[0][i]);\n        while(!q.empty()){\n            int u=q.front();q.pop();\n            for(int i=0;i<26;++i)\n\t            if(e[u][i])fail[e[u][i]]=e[fail[u]][i],q.push(e[u][i]);\n\t            else e[u][i]=e[fail[u]][i];\n        }\n    }\n    int query(char* p){\n        int len=strlen(p),j=0,sum=0;\n        for(int i=0;i<len;++i){\n            int x=p[i]-'a';j=e[j][x];int t=j;\n            while(t&&val[t]!=-1)sum+=val[t],val[t]=-1,t=fail[t];\n        }\n        return sum;\n    }\n}at;\n```",
        "title": "\u5b57\u7b26\u4e32\u5339\u914d\u5165\u95e8",
        "categories": [
            "[\u968f\u7b14\u5206\u7c7b]\u81ea\u7136\u8bed\u8a00\u5904\u7406",
            "[\u968f\u7b14\u5206\u7c7b]\u7b97\u6cd5"
        ],
        "enclosure": {
            "length": 0
        },
        "link": "https://www.cnblogs.com/chanceYu/p/12112354.html",
        "permalink": "https://www.cnblogs.com/chanceYu/p/12112354.html",
        "postid": "12112354",
        "source": {},
        "userid": "-2"
    },
    {
        "dateCreated": "20191223T14:00:00",
        "description": "## Descriprion\nIf you smiled when you see the title, this problem is for you ^_^)For those who don\u2019t know KTV, see: http://en.wikipedia.org/wiki/Karaoke_boxThere is one very popular song called Jin Ge Jin Qu(). It is a mix of 37 songs, and is extremelylong (11 minutes and 18 seconds) \u2014 I know that there are Jin Ge Jin Qu II and III, and some otherunofficial versions. But in this problem please forget about them.Why is it popular? Suppose you have only 15 seconds left (until your time is up), then you shouldselect another song as soon as possible, because the KTV will not crudely stop a song before it ends(people will get frustrated if it does so!). If you select a 2-minute song, you actually get 105 extraseconds! ....and if you select Jin Ge Jin Qu, you\u2019ll get 663 extra seconds!!!Now that you still have some time, but you\u2019d like to make a plan now. You should stick to thefollowing rules:\n\n\u2022 Don\u2019t sing a song more than once (including Jin Ge Jin Qu)\n\n\u2022 For each song of length t, either sing it for exactly t seconds, or don\u2019t sing it at all\n\n\u2022 When a song is finished, always immediately start a new song.Your goal is simple: sing as many songs as possible, and leave KTV as late as possible (since wehave rule 3, this also maximizes the total lengths of all songs we sing) when there are ties.\n## Input Instruction\nThe first line contains the number of test cases T (T \u2264 100). Each test case begins with two positiveintegers n, t (1 \u2264 n \u2264 50, 1 \u2264 t \u2264 109), the number of candidate songs (BESIDES Jin Ge Jin Qu)and the time left (in seconds). The next line contains n positive integers, the lengths of each song, inseconds. Each length will be less than 3 minutes \u2014 I know that most songs are longer than 3 minutes.But don\u2019t forget that we could manually \u201ccut\u201d the song after we feel satisfied, before the song ends.So here \u201clength\u201d actually means \u201clength of the part that we want to sing\u201d.It is guaranteed that the sum of lengths of all songs (including Jin Ge Jin Qu) will be strictly largerthan t.\n## Output Instruction\nFor each test case, print the maximum number of songs (including Jin Ge Jin Qu), and the total lengthsof songs that you\u2019ll sing.Explanation:In the first example, the best we can do is to sing the third song (80 seconds), then Jin Ge Jin Qufor another 678 seconds.In the second example, we sing the first two (30+69=99 seconds). Then we still have one secondleft, so we can sing Jin Ge Jin Qu for extra 678 seconds. However, if we sing the first and third songinstead (30+70=100 seconds), the time is already up (since we only have 100 seconds in total), so wecan\u2019t sing Jin Ge Jin Qu anymore!\n>## Sample Input\n\n2\n3 100\n60 70 80\n3 100\n30 69 70\n>## Sample Output\n\nCase 1: 2 758\nCase 2: 3 777\n>## Analysis\n\n\u627e\u5c0f\u4e8eT\u7684\u6ee1\u8db3\u53cc\u6761\u4ef6\u6700\u503c\uff0c\u53ef\u4ee5\u6bcf\u6b65\u5224\u65ad-->\u53d6\u7aef\u70b9\uff0c\u4e5f\u53ef\u4ee5\u6700\u540e\u5224\u65ad-->\u53d6\u6700\u503c\n\n### Code\n\u6cd51:\u6bcf\u6b21\u53cc\u6761\u4ef6\u6bd4\u8f83\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,m,t,i,j,r;\n    scanf(\"%d\",&n);\n    for(i=0;i<n;++i){\n        scanf(\"%d%d\",&m,&t);\n        vector<int>dp(t+1,0),has(t+1,0);\n        for(j=1;j<=m;++j){\n            scanf(\"%d\",&r);\n            for(int k=t;k>r;--k){\n                if(dp[k-r]+1>dp[k]){dp[k]=dp[k-r]+1;has[k]=has[k-r]+r;}\n                else if(dp[k-r]+1==dp[k]&&has[k-r]+r>has[k])has[k]=has[k-r]+r;\n            }\n        }\n        printf(\"Case %d: %d %d\\n\",i+1,dp[t]+1,has[t]+678);\n    }\n    return 0;\n}\n```\n\u6cd52\uff1a\u53bb\u6389\u4e0d\u53ef\u8fbe\u7ed3\u70b9+\u6700\u540e\u6bd4\u8f83\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,m,t,i,j,r,ans;\n    scanf(\"%d\",&n);\n    for(i=0;i<n;++i){\n        scanf(\"%d%d\",&m,&t);\n        vector<int>dp(t+1,-1);dp[0]=0;\n        for(j=1;j<=m;++j){\n            scanf(\"%d\",&r);\n            for(int k=t-1;k>=r;--k)dp[k]=max(dp[k],dp[k-r]+1);\n        }\n        for(ans=j=t-1;j>=0;--j)if(dp[ans]<dp[j])ans=j;\n        printf(\"Case %d: %d %d\\n\",i+1,dp[ans]+1,ans+678);\n    }\n    return 0;\n}\n```",
        "title": "UVA12563 Jin Ge Jin Qu hao",
        "categories": [
            "[\u968f\u7b14\u5206\u7c7b]\u7b97\u6cd5"
        ],
        "enclosure": {
            "length": 0
        },
        "link": "https://www.cnblogs.com/chanceYu/p/12083401.html",
        "permalink": "https://www.cnblogs.com/chanceYu/p/12083401.html",
        "postid": "12083401",
        "source": {},
        "userid": "-2"
    },
    {
        "dateCreated": "20191221T19:49:00",
        "description": "## Problem Description\nProblems that require minimum paths through some domain appear in many different areas of computer science. For example, one of the constraints in VLSI routing problems is minimizing wire length. The Traveling Salesperson Problem (TSP) -- finding whether all the cities in a salesperson's route can be visited exactly once with a specified limit on travel time -- is one of the canonical examples of an NP-complete problem; solutions appear to require an inordinate amount of time to generate, but are simple to check. \n\nThis problem deals with finding a minimal path through a grid of points while traveling only from left to right. \n\nGiven an m*n matrix of integers, you are to write a program that computes a path of minimal weight. A path starts anywhere in column 1 (the first column) and consists of a sequence of steps terminating in column n (the last column). A step consists of traveling from column i to column i+1 in an adjacent (horizontal or diagonal) row. The first and last rows (rows 1 and m) of a matrix are considered adjacent, i.e., the matrix ``wraps'' so that it represents a horizontal cylinder. Legal steps are illustrated below. \n![a](http://acm.hdu.edu.cn/data/images/1619-1.gif)\nThe weight of a path is the sum of the integers in each of the n cells of the matrix that are visited. \n\nFor example, two slightly different 5*6 matrices are shown below (the only difference is the numbers in the bottom row). \n![a](http://acm.hdu.edu.cn/data/images/1619-2.gif)\nThe minimal path is illustrated for each matrix. Note that the path for the matrix on the right takes advantage of the adjacency property of the first and last rows. \n\n## Input\nThe input consists of a sequence of matrix specifications. Each matrix specification consists of the row and column dimensions in that order on a line followed by integers where m is the row dimension and n is the column dimension. The integers appear in the input in row major order, i.e., the first n integers constitute the first row of the matrix, the second n integers constitute the second row and so on. The integers on a line will be separated from other integers by one or more spaces. Note: integers are not restricted to being positive. There will be one or more matrix specifications in an input file. Input is terminated by end-of-file. \n\nFor each specification the number of rows will be between 1 and 10 inclusive; the number of columns will be between 1 and 100 inclusive. No path's weight will exceed integer values representable using 30 bits\n## Output\nTwo lines should be output for each matrix specification in the input file, the first line represents a minimal-weight path, and the second line is the cost of a minimal path. The path consists of a sequence of n integers (separated by one or more spaces) representing the rows that constitute the minimal path. If there is more than one path of minimal weight the path that is lexicographically smallest should be output. \n\n## Sample Input\n>5 6\n3 4 1 2 8 6\n6 1 8 2 7 4\n5 9 3 9 9 5\n8 4 1 3 2 6\n3 7 2 8 6 4\n5 6\n3 4 1 2 8 6\n6 1 8 2 7 4\n5 9 3 9 9 5\n8 4 1 3 2 6\n3 7 2 1 2 3\n2 2\n9 10 9 10\n\n## Sample Output\n>1 2 3 4 4 5\n16\n1 2 1 5 4 5\n11\n1 1\n19\n\n## code\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n;\ninline bool cmp(vector<int>&a,vector<int>&b){\n    int i=0;\n    while(i<n-1&&a[i]==b[i])++i;\n    return a[i]<b[i];\n}\nvoid dfs(int x,vector<vector<int>>& post,vector<int>& v){\n    vector<int> temp(n,0);\n    for(int i=0;i<n;++i){temp[i]=x;x=post[i][x];}\n    if(cmp(temp,v)==1)v=temp;\n}\nint main(){\n    int m,i,j,total;\n    while(~scanf(\"%d%d\",&m,&n)){\n        vector<vector<int>>g(m,vector<int>(n,0));\n        vector<int> v(n,m-1);\n        vector<vector<int>>dp(n,vector<int>(m,0));//colum\n        vector<vector<int>>post(n,vector<int>(m,0));//colum\n        for(i=0;i<m;++i)for(j=0;j<n;++j)scanf(\"%d\",&g[i][j]);\n        for(i=0;i<m;++i)dp[n-1][i]=g[i][n-1];\n        for(i=n-2;i>=0;--i)\n        for(j=0;j<m;++j){\n            int x=j-1<0?j-1+m:j-1;int y=j+1>m-1?j+1-m:j+1;\n            int p[3]={dp[i+1][j]+g[j][i],dp[i+1][x]+g[j][i],dp[i+1][y]+g[j][i]};\n            int sq=*min_element(p,p+3);dp[i][j]=sq;\n            vector<int>xx;\n            if(p[0]==sq)xx.push_back(j);\n            if(p[1]==sq)xx.push_back(x);\n            if(p[2]==sq)xx.push_back(y);\n            post[i][j]=*min_element(xx.begin(),xx.end());\n        }\n        total=*min_element(dp[0].begin(),dp[0].end());\n        for(i=0;i<m;++i)if(dp[0][i]==total)dfs(i,post,v);\n        for(i=0;i<n;++i){\n            printf(\"%d\",v[i]+1);\n            if(i!=n-1)printf(\" \");\n        }\n        printf(\"\\n%d\\n\",total);\n    }\n    return 0;\n}\n\n```\n### comment\n\u53ef\u4ee5\u4ece\u641c\u7d22\u7b56\u7565\u89e3\u51b3\u5b57\u5178\u5e8f\u95ee\u9898\uff0c\u4e0d\u8981\u5148\u6392\u540e\u5904\u7406\n```cpp\nfor(int i=0; i<n; i++)\n   if(ans>dp[i][0]) {\n\tans=dp[i][0];\n\tk=i;\n   }\n}\n```",
        "title": "HDU1619 Unidirectional TSP ",
        "categories": [
            "[\u968f\u7b14\u5206\u7c7b]\u7b97\u6cd5"
        ],
        "enclosure": {
            "length": 0
        },
        "link": "https://www.cnblogs.com/chanceYu/p/12078049.html",
        "permalink": "https://www.cnblogs.com/chanceYu/p/12078049.html",
        "postid": "12078049",
        "source": {},
        "userid": "-2"
    },
    {
        "dateCreated": "20191218T14:49:00",
        "description": "## \u9898\u76ee\n\nJohn Doe, a skilled pilot, enjoys traveling. While on vacation, he rents a small plane and starts visiting beautiful places. To save money, John must determine the shortest closed tour that connects his destinations. Each destination is represented by a point in the plane pi = . John uses the following strategy: he starts from the leftmost point, then he goes strictly left to right to the rightmost point, and then he goes strictly right back to the starting point. It is known that the points have distinct x-coordinates.\n\nWrite a program that, given a set of n points in the plane, computes the shortest closed tour that connects the oints according to John's strategy.\n>### Input\n\nEach data set in the file stands for a particular set of points. For each set of points the data set contains the number of points, and the point coordinates in ascending order of the x coordinate. White spaces can occur freely in input. The input data are correct.\n\n>### Output\n\nFor each set of data, your program should print the result to the standard output from the beginning of a line. The tour length, a floating-point number with two fractional digits, represents the result. An input/output sample is in the table below. Here there are two data sets. The first one contains 3 points specified by their x and y coordinates. The second point, for example, has the x coordinate 2, and the y coordinate 3. The result for each data set is the tour length, (6.47 for the first data set in the given example).\n\n## Sample Input\n\n3\n1 1\n2 3\n3 1\n4\n1 1\n2 3\n3 1\n4 2\n\n## Sample Output\n\n6.47\n7.89\n## \u601d\u8def\u5206\u6790\n\u5237\u8868\u6cd5--\u8003\u8651\u6bcf\u4e2a\u72b6\u6001\u5f71\u54cd\u5230\u7684\u72b6\u6001\n\u586b\u8868\u6cd5--\u8003\u8651\u6bcf\u4e2a\u72b6\u6001\u7684\u4f9d\u8d56\n\u72b6\u6001\u65b9\u5411\uff1ahas/remain\n\n>### \u6cd51\uff1a\u5237\u8868\u6cd5\n\nd(i,j)=min(d(i+1,j)+dist(i,i+1),d(i+1,i)+dist(j,i+1));\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nfloat d(int xi,int yi,int xj,int yj){\n    return sqrt((xi-xj)*(xi-xj)+(yi-yj)*(yi-yj));\n}\nint main(){\n    int n,i,j;\n    while(~scanf(\"%d\",&n)){\n        vector<int> x(n),y(n);\n        vector<vector<float>> dp(n,vector<float>(n,0.0));\n        for(i=0;i<n;++i)scanf(\"%d%d\",&x[i],&y[i]);\n        for(i=n-2;i>=0;--i)dp[n-1][i]=d(x[i],y[i],x[n-1],y[n-1]);\n        for(i=n-2;i>=0;--i)\n        for(j=0;j<=(i==0?i:i-1);++j)\n        dp[i][j]=min(dp[i+1][j]+d(x[i],y[i],x[i+1],y[i+1]),dp[i+1][i]+d(x[j],y[j],x[i+1],y[i+1]));\n        printf(\"%.2f\\n\",dp[0][0]);\n    }\n    return 0;\n}\n```\n>### \u6cd52:\u586b\u8868\u6cd5\n\n\u5f53j < i-1\u65f6 d[i][j] = d[i-1][j] + dist[i][i-1]; \n\u5f53j = i-1\u65f6 d[i][j] = min(d[i][j],d[i-1][k] + dist[i][k]) (k:0->i-2);\n\n## \u4ee3\u7801 \n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nfloat d(int xi,int yi,int xj,int yj){\n    return sqrt((xi-xj)*(xi-xj)+(yi-yj)*(yi-yj));\n}\nint main(){\n    int n,i,j;\n    while(~scanf(\"%d\",&n)){\n        vector<int> x(n),y(n);\n        vector<vector<float>> dp(n,vector<float>(n,0.0));\n        for(i=0;i<n;++i)scanf(\"%d%d\",&x[i],&y[i]);\n        dp[1][0]=d(x[1],y[1],x[0],y[0]);\n        for(i=2;i<n;++i){\n            for(j=0;j<i-1;++j)dp[i][j]=dp[i-1][j]+d(x[i-1],y[i-1],x[i],y[i]);\n            dp[i][j]=dp[i-1][0]+d(x[0],y[0],x[i],y[i]);\n            for(int k=1;k<i-1;++k)\n            dp[i][j]=min(dp[i][j],dp[i-1][k]+d(x[k],y[k],x[i],y[i]));\n        }\n        printf(\"%.2f\\n\",dp[n-1][n-2]+d(x[n-2],y[n-2],x[n-1],y[n-1]));\n    }\n    return 0;\n}\n```",
        "title": "ZOJ2581Tour",
        "categories": [
            "[\u968f\u7b14\u5206\u7c7b]\u7b97\u6cd5"
        ],
        "enclosure": {
            "length": 0
        },
        "link": "https://www.cnblogs.com/chanceYu/p/12059832.html",
        "permalink": "https://www.cnblogs.com/chanceYu/p/12059832.html",
        "postid": "12059832",
        "source": {},
        "userid": "-2"
    },
    {
        "dateCreated": "20191217T20:11:00",
        "description": "## \u9898\u76ee\n&emsp;&emsp;Secret agent Maria was sent to Algorithms City to carry out an especially dangerous mission. After several thrilling events we find her in the first station of Algorithms City Metro, examining the time table. The Algorithms City Metro consists of a single line with trains running both ways, so its time table is not complicated.\n&emsp;&emsp;Maria has an appointment with a local spy at the last station of Algorithms City Metro. Maria knows that a powerful organization is after her. She also knows that while waiting at a station, she is at great risk of being caught. To hide in a running train is much safer, so she decides to stay in running trains as much as possible, even if this means traveling backward and forward. Maria needs to know a schedule with minimal waiting time at the stations that gets her to the last station in time for her appointment. You must write a program that finds the total waiting time in a best schedule for Maria.\n&emsp;&emsp;The Algorithms City Metro system has N stations, consecutively numbered from 1 to N. Trains move in both directions: from the first station to the last station and from the last station back to the first station. The time required for a train to travel between two consecutive stations is fixed since all trains move at the same speed. Trains make a very short stop at each station, which you can ignore for simplicity. Since she is a very fast agent, Maria can always change trains at a station even if the trains involved stop in that station at the same time.\n![Devcpp](https://images.cnblogs.com/cnblogs_com/chanceYu/1613483/o_191217053559QQ\u622a\u56fe20191217133538.png)\n## Input structions\nThe input file contains several test cases. Each test case consists of seven lines with information as follows.\nLine 1. The integer N (2 \u2264 N \u2264 50), which is the number of stations.\nLine 2. The integer T (0 \u2264 T \u2264 200), which is the time of the appointment.\nLine 3. N \u2212 1 integers: t1, t2, . . . , tN\u22121 (1 \u2264 ti \u2264 20), representing the travel times for the trains between two consecutive stations: t1 represents the travel time between the first two stations, t2 the time between the second and the third station, and so on.\nLine 4. The integer M1 (1 \u2264 M1 \u2264 50), representing the number of trains departing from the first station.\nLine 5. M1 integers: d1, d2, . . . , dM1 (0 \u2264 di \u2264 250 and di < di+1), representing the times at which trains depart from the first station.\nLine 6. The integer M2 (1 \u2264 M2 \u2264 50), representing the number of trains departing from the N-th station.\nLine 7. M2 integers: e1, e2, . . . , eM2 (0 \u2264 ei \u2264 250 and ei < ei+1) representing the times at which trains depart from the N-th station.\nThe last case is followed by a line containing a single zero.\n## Output\nFor each test case, print a line containing the case number (starting with 1) and an integer representing\nthe total waiting time in the stations for a best schedule, or the word \u2018impossible\u2019 in case Maria is\nunable to make the appointment. Use the format of the sample output\n## \u5206\u6790\u4e0e\u7406\u89e3\n\"The Algorithms City Metro consists of a single line with trains running both ways\"--\u53cc\u5411\u901a\u884c\uff0c\u4f46\u5e76\u4e0d\u5faa\u73af\n\u7136\u540e\u9488\u5bf9\u8fd9\u4e2a\u95ee\u9898\uff0c\u7b49\u5f85\u65f6\u95f4\u662f\u5404\u7ad9\u7b49\u5f85\u65f6\u95f4\u4e4b\u548c-->\u5bf9\u7ad9\u9012\u63a8,\u51b3\u7b56\u53ea\u4e0e\u65f6\u95f4\u548c\u7ad9\u70b9\u6709\u5173\n## \u4ee3\u7801\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n=1,T,m1,m2,i,j,fr_sum=0,bk_sum=0,sq=1;\n    while(~scanf(\"%d\",&n),n){\n        scanf(\"%d\",&T);\n        vector<int> t(n-1);\n        vector<vector<int>>fr_train(T+1,vector<int>(n));\n        vector<vector<int>>bk_train(T+1,vector<int>(n));\n        vector<vector<int>>dp(T+1,vector<int>(n));\n        for(auto &p:t)scanf(\"%d\",&p);\n        scanf(\"%d\",&m1);vector<int> fr(m1);\n        for(auto &p:fr){scanf(\"%d\",&p);fr_sum+=p;}\n        scanf(\"%d\",&m1);vector<int> bk(m1);\n        for(auto &p:bk){scanf(\"%d\",&p);bk_sum+=p;}\n        for(auto &p:fr){\n            int x=0;\n            for(i=0;(x=p+i*fr_sum+i*bk_sum)<=T;++i){\n                fr_train[x][0]=1;\n                for(j=0;j<n-1;++j){\n                    if((x+=t[j])<=T)fr_train[x][j+1]=1;\n                    else break;\n                }\n            }\n        }\n        for(auto &p:bk){\n            int x=0;\n            for(i=0;(x=p+i*fr_sum+i*bk_sum)<=T;++i){\n                bk_train[x][n-1]=1;\n                for(j=n-1;j>0;--j){\n                    if((x+=t[j-1])<=T)bk_train[x][j-1]=1;\n                    else break;\n                }\n            }\n        }\n        dp[T][n-1]=0;\n        for(i=n-2;i>=0;--i)dp[T][i]=T+1;\n        for(i=T-1;i>=0;--i)\n        for(j=n-1;j>=0;--j){\n            dp[i][j]=dp[i+1][j]+1;\n            if(fr_train[i][j]==1&&i+t[j]<=T&&j+1<n)dp[i][j]=min(dp[i+t[j]][j+1],dp[i][j]);\n            if(bk_train[i][j]==1&&i+t[j-1]<=T&&j-1>=0)dp[i][j]=min(dp[i+t[j-1]][j-1],dp[i][j]);\n        }\n        printf(\"Case Number %d: \",sq);\n        if(dp[0][0]>T)printf(\"impossible\\n\");\n        else printf(\"%d\\n\",dp[0][0]);\n        sq++;\n    }\n    return 0;\n}\n```\n### ,\u8868\u8fbe\u5f0f\n\u9017\u53f7\u8fd0\u7b97\u7b26\uff0c\u4f18\u5148\u7ea7\u522b\u6700\u4f4e\uff0c\u5b83\u5c06\u4e24\u4e2a\u53ca\u5176\u4ee5\u4e0a\u7684\u5f0f\u5b50\u8054\u63a5\u8d77\u6765\uff0c\u4ece\u5de6\u5f80\u53f3\u9010\u4e2a\u8ba1\u7b97\u8868\u8fbe\u5f0f\uff0c\u6574\u4e2a\u8868\u8fbe\u5f0f\u7684\u503c\u4e3a\u6700\u540e\u4e00\u4e2a\u8868\u8fbe\u5f0f\u7684\u503c\u3002\u5982\uff1a\uff083+5,6+8\uff09\u79f0\u4e3a\u9017\u53f7\u8868\u8fbe\u5f0f\uff0c\u5176\u6c42\u89e3\u8fc7\u7a0b\u5148\u8868\u8fbe\u5f0f1\uff0c\u540e\u8868\u8fbe\u5f0f2\uff0c\u6574\u4e2a\u8868\u8fbe\u5f0f\u503c\u662f\u8868\u8fbe\u5f0f2\u7684\u503c\uff0c\u5982\uff1a\uff083+5\uff0c6+8\uff09\u7684\u503c\u662f14\uff1b$a=(a=3*5,a*4)$\u7684\u503c\u662f60\uff0c\u5176\u4e2d$\uff08a=3*5,a*4\uff09$\u7684\u503c\u662f60\uff0c a\u7684\u503c\u5728\u9017\u53f7\u8868\u8fbe\u5f0f\u91cc\u4e00\u76f4\u662f15\uff0c\u6700\u540e\u88ab\u9017\u53f7\u8868\u8fbe\u5f0f\u8d4b\u503c\u4e3a60\uff0ca\u7684\u503c\u6700\u7ec8\u4e3a60\u3002",
        "title": "UVA1025 A Spy in the Metro",
        "categories": [
            "[\u968f\u7b14\u5206\u7c7b]\u7b97\u6cd5"
        ],
        "enclosure": {
            "length": 0
        },
        "link": "https://www.cnblogs.com/chanceYu/p/12056578.html",
        "permalink": "https://www.cnblogs.com/chanceYu/p/12056578.html",
        "postid": "12056578",
        "source": {},
        "userid": "-2"
    },
    {
        "dateCreated": "20191215T19:56:00",
        "description": "### 1048 Longest String Chain\nGiven a list of words, each word consists of English lowercase letters.\n\nLet's say word1 is a predecessor of word2 if and only if we can add exactly one letter anywhere in word1 to make it equal to word2.  For example, \"abc\" is a predecessor of \"abac\".\n\nA word chain is a sequence of words [word_1, word_2, ..., word_k] with k >= 1, where word_1 is a predecessor of word_2, word_2 is a predecessor of word_3, and so on.\n\nReturn the longest possible length of a word chain with words chosen from the given list of words.\n>Example 1:\n\nInput: [\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"]\nOutput: 4\nExplanation: one of the longest word chain is \"a\",\"ba\",\"bda\",\"bdca\".\n> Note:\n\n1 <= words.length <= 1000\n1 <= words[i].length <= 16\nwords[i] only consists of English lowercase letters.\n#### Clean Code\n```cpp\nclass Solution {\npublic:\n    static bool compare(const string &s1, const string &s2) {\n        return s1.length() < s2.length();\n    }\n\n    int longestStrChain(vector<string>& words) {\n        sort(words.begin(), words.end(), compare);\n        unordered_map<string, int> dp;\n        int res = 0;\n        for (string w : words) {\n            int best = 0;\n            for (int i = 0; i < w.length(); i++) {\n                string word = w.substr(0, i) + w.substr(i + 1);\n                best = max(best, dp[word] + 1);\n            }\n            dp[w] = best;\n            res = max(res, best);\n        }\n        return res;\n    }\n}\n```",
        "title": "leetcode1048",
        "categories": [
            "[\u968f\u7b14\u5206\u7c7b]Leetcode"
        ],
        "enclosure": {
            "length": 0
        },
        "link": "https://www.cnblogs.com/chanceYu/p/12045635.html",
        "permalink": "https://www.cnblogs.com/chanceYu/p/12045635.html",
        "postid": "12045635",
        "source": {},
        "userid": "-2"
    },
    {
        "dateCreated": "20191214T13:53:00",
        "description": "\u4f18\u5148\u961f\u5217\u7684\u4f7f\u7528\n```cpp\nclass Solution {\npublic:\n    string alienOrder(vector<string> &words) {\n        unordered_map<char,vector<char>> mp;unordered_map<char,int> in;\n        unordered_set<char> dic;\n        string temp;\n        for(int i=0;i<words.size();++i){\n            string p=words[i];int j=0;\n            dic.insert(words[i].begin(),words[i].end());\n            if(i!=0){\n                while(p[j]==temp[j])++j;\n                mp[temp[j]].push_back(p[j]);\n                in[p[j]]++;\n            }\n            temp=p;\n        }\n        for(auto &p:dic)in[p]++;\n        priority_queue<char,vector<char>,greater<char>>q;temp=\"\";\n        for(char i='a';i<='z';++i)if(in[i]==1)q.push(i);\n        while(!q.empty()){\n            char x=q.top();\n            q.pop();temp+=x;\n            for(auto &p:mp[x])if(--in[p]==1)q.push(p);\n        }\n        if(temp.size()!=dic.size())temp=\"\";\n        return temp;\n    }\n};\n```",
        "title": "leetcode269 Alien Dictionary",
        "categories": [
            "[\u968f\u7b14\u5206\u7c7b]Leetcode"
        ],
        "enclosure": {
            "length": 0
        },
        "link": "https://www.cnblogs.com/chanceYu/p/12038969.html",
        "permalink": "https://www.cnblogs.com/chanceYu/p/12038969.html",
        "postid": "12038969",
        "source": {},
        "userid": "-2"
    },
    {
        "dateCreated": "20191213T20:58:00",
        "description": "<script type=\"text/javascript\" src=\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"></script>\n<script type=\"text/x-mathjax-config\">\n    MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: \"none\" });\n</script>\n\n<table>\n   <tr>\n      <td>\u7b97\u6cd5</td>\n      <td>\u7c7b\u578b</td>\n      <td>Structure</td>\n      <td>function</td>\n      <td>\u5907\u6ce8</td>\n   </tr>\n   <tr>\n      <td rowspan=\"4\" width=\"80\">\u4e0d\u53d8\u5e8f\u5217\u7b97\u6cd5O(n)</td>\n      <td rowspan=\"4\" colspan=\"2\" width=\"80\">\u987a\u5e8f\u5bb9\u5668/\u5173\u8054\u5bb9\u5668\u5747\u9002\u7528</td>\n      <td>iterator min_element(iterator first, iterator last[,Pred op])</td>\n      <td></td>\n   </tr>\n   <tr>\n      <td>iterator max_element(iterator first, iterator last[,Pred op])</td>\n      <td></td>\n   </tr>\n   <tr>\n      <td>int count(iterator first, iterator last,const T& val)</td>\n      <td></td>\n   </tr>\n   <tr>\n      <td>iterator find(iterator first, iterator last,const T& val)</td>\n      <td></td>\n   </tr>\n   <tr>\n      <td rowspan=\"7\">\u63d2\u5165\u7b97\u6cd5\u7b2c\u4e00\u4e2a\u88ab\u63d2\u5165\u5143\u7d20\u7684\u8fed\u4ee3\u5668first</td>\n      <td rowspan=\"3\" width=\"40\">Single element</td>\n      <td width=\"40\">vector</td>\n      <td>iterator insert (const_iterator position, const value_type& val);</td>\n      <td></td>\n   </tr>\n   <tr>\n      <td>set</td>\n      <td>pair&lt;iterator,bool> insert (const value_type& val);</td>\n      <td>pair::second inserted(1)or existed(0)</td>\n   </tr>\n   <tr>\n      <td>String</td>\n      <td>string& insert (size_t pos, const char* s);</td>\n      <td></td>\n   </tr>\n   <tr>\n      <td rowspan=\"2\">Fill</td>\n      <td>vector</td>\n      <td>iterator insert (const_iterator position, size_type n, const value_type& val);</td>\n      <td></td>\n   </tr>\n   <tr>\n      <td>String</td>\n      <td>string& insert (size_t pos, size_t n, char c);</td>\n      <td></td>\n   </tr>\n   <tr>\n      <td>Range</td>\n      <td>vector,String</td>\n      <td>iterator insert (const_iterator position, InputIterator first, InputIterator last);</td>\n      <td></td>\n   </tr>\n   <tr>\n      <td>Buffer</td>\n      <td>String</td>\n      <td>string& insert(size_t pos, const string& str, size_t subpos, size_t sublen);</td>\n      <td>\u4e2a\u6570</td>\n   </tr>\n   <tr>\n      <td rowspan=\"3\">\u5220\u9664\u7b97\u6cd5\u8fd4\u56de\u88ab\u5220\u9664\u5143\u7d20\u7684\u4e0b\u4e00\u4e2a\u8fed\u4ee3\u5668last</td>\n      <td>Single element</td>\n      <td>vector,set</td>\n      <td>iterator erase (const_iterator position);</td>\n      <td></td>\n   </tr>\n   <tr>\n      <td>Unfill</td>\n      <td>set</td>\n      <td>size_type erase(const value_type& val);</td>\n      <td>\u4e2a\u6570</td>\n   </tr>\n   <tr>\n      <td>Range</td>\n      <td>vector,set</td>\n      <td>iterator erase(const_iterator first, const_iterator last);</td>\n      <td></td>\n   </tr>\n</table>\n1.\u8f93\u5165\u65b9\u5f0f\u5927\u603b\u7ed3\n\n>getline(cin,str):  \nstd::basic_istream& getline(std::basic_istream&__is, std::__cxx11::basic_string& __str);\n```cpp\n//\u89e3\u6790\u4e00\u4e2a\u5b57\u7b26\u7684\u4e09\u79cd\u65b9\u5f0f\nscanf(\"%c\",&ch);\nch=cin.get();\nch=getchar();\n//\u89e3\u6790\u4e00\u4e2a\u5b57\u7b26\u4e32\u7684\u65b9\u5f0f\nchar m[20];//gets\u51fd\u6570\u5982\u679c\u8bfb\u53d6\u4e86\u6362\u884c\u7b26\u4f1a\u5c06\u5176\u81ea\u52a8\u8f6c\u6362\u6210\u5b57\u7b26\u4e32\u7ed3\u675f\u7b26'\\0'\ngets(m);     \ncin.getline(m,5);//\u591a\u4e86\u4e00\u4e2a\u53c2\u6570\uff0c\u53ef\u4ee5\u52a0\u7ed3\u675f\u7b26\ncin.get(m,20);//\u591a\u4e86\u4e00\u4e2a\u53c2\u6570\uff0c\u53ef\u4ee5\u52a0\u7ed3\u675f\u7b26\n```\n>%2d\u5c31\u662f\u5c06\u6570\u5b57\u6309\u7167\u5bbd\u5ea6\u4e3a2 \u91c7\u7528\u53f3\u5bf9\u9f50\u65b9\u5f0f\u8f93\u51fa\uff0c\u82e5\u6570\u636e\u4f4d\u6570\u4e0d\u52302\u4f4d\uff0c\u5219\u5de6\u8fb9\u8865\u7a7a\u683c\n\n>%02d\u548c%2d\u5dee\u4e0d\u591a \u53ea\u4e0d\u8fc7\u5de6\u8fb9\u88650\n\n>toupper,tolower\u7684\u4f7f\u7528\n\n2.\"\u5bf9\u5e94\"\u7684\u5904\u7406\n\n##### `\u6cd51:\u5efa\u8868`\n```cpp\nchar c[14] = {\"0123456789ABC\"};\nprintf(\"#\");\nfor(int i = 0; i < 3; i++) {\n    int num;\n    scanf(\"%d\", &num);\n    printf(\"%c%c\", c[num/13], c[num%13]);\n}\nreturn 0;\n```\n##### `\u6cd52:\u76f4\u63a5\u51fd\u6570\u8f93\u51fa`\n\n3.cmp\u7684\u5199\u6cd5\n```cpp\nint cmp(node& a, node& b) {//Tips:\u5f15\u7528\u4f20\u9012\u548c\u5730\u5740\u4f20\u9012\u6548\u7387\u9ad8\u4e8e\u76f4\u63a5\u4f20\u9012\n\tif ((a.de1 + a.cai) != (b.de + b.cai))        \n        return (a.de + a.cai) > (b.de + b.cai);//\u6280\u5de7:\u4ee5\u6c42\u548c\u4ee3\u66ff\u6c42\u5e73\u5747\u503c\n\telse if (a.de != b.de) return a.de > b.de;\n\telse return strcmp(a.name, b.name) < 0;//char name[9]\n        //\u8fd8\u53ef\u4ee5string a.name<b.name;\n}\n```\n> \u5e76\u5217\u6392\u540d\u95ee\u9898\n```cpp\nstruct node {\n\tint id, best;\n\tint score[4], rank[4];\n};//\u4e00\u822c\u4e00\u4e2a\u7ed3\u6784\u4f53\nfor(i=0;i<sch.size();++i){\n for(j=0;j<k;++j){\n        bool y;\n        int choice=sch[i].sc[j];\n        int x=ans[choice].size();\n        if(x>0){\n            int last=x-1;\n            y=sch[i].grade[0]==ans[choice][last].grade[0]&&sch[i].grade[1]==ans[choice][last].grade[1];\n            x=y?ans[choice][last].rank:x;\n        }\n        if(x<full[choice]||y){\n            ans[sch[i].sc[j]].push_back(sch[i];\n            break;\n        }\n}\nfor(flag = 0; flag <= 2; flag++) {\n        sort(ans.begin(), ans.end(), cmp1);\n        for(int i = 0; i < n; i++) {\n            ans[i].rank[flag] = i;\n            if(i>0&&ans[i].grade[flag] == ans[i-1].grade[flag])//\u6ce8\u610f\u591a\u4e00\u4e2a\u5224\u65ad\u8fd8\u6709\u53cd\u5411            \n            ans[i].ans[flag] = ans[i-1].rank[flag];\n        }\n}\n```\n4.\u8f93\u51fa\u683c\u5f0f\n>flag\u8bbe\u7f6e\u95ee\u9898\n\n*Leetcode98 \u6307\u9488\u7a7a\u95f4\u590d\u6742\u5ea6O(1)*\n```cpp\nint* last = NULL;//flag\nbool isValidBST(TreeNode* root) {\n   if (root){\n         if(!isValidBST(root->left)) return false;\n         if (last && *last>=root->val) return false;//\u7b2c\u4e00\u6b21\u667a\u6167\u6267\u884c\u4e0b\u9762\n         last = &root->val;\n         if(!isValidBST(root->right)) return false;\n         return true;\n   }else return true;\n};\n```\n\n>\u666e\u901a\u8f93\u51fa\u95ee\u9898\n```cpp\nfor (int i = 0; i < 4; i++) {\n\tsort(v[i].begin(), v[i].end(), cmp);\n\tfor (int j = 0; j < v[i].size(); j++){//\u5c0f\u6280\u5de7:\u5229\u7528\u987a\u5e8f\u6761\u4ef6\uff0c\u5982\u6c42\u4e00\u4e32\u7801\u4e2d\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u5143\u7d20\n        if(j!=0)printf(\" \");\n\t\tprintf(\"%d\", v[i][j].num);\n    }\n    printf(\"\\n\");\n}\n```\n>\u6761\u4ef6\u8865\u96f6\u95ee\u9898Eg:\u4fdd\u7559n\u4f4d\u5c0f\u6570(temp.size\u53ef\u5927\u53ef\u5c0f)\n```cpp\nwhile(temp.size()<N)//\u6709\u6548\u6570\u5b57\u4f4d\u6570\u5c0f\u4e8eN\ntemp+=\"0\";//\u5728\u5b57\u7b26\u4e32\u672b\u5c3e\u52a0\u8db3\u591f\u76840\u4fdd\u8bc1\u6709N\u4f4d\u6709\u6548\u6570\u5b57\n```\n\n5.\u6392\u5e8f\u9898\n\n>\u591a\u7ef4\u6392\u5e8f-->\u627e\u53c2\u8003\u7cfb\n\n`1\u6bd4\u8f83\u65f6\u95f4\u5b9e\u9645\u53ef\u4ee5t[j]-t[i](\u4ece0:0:0\u5f00\u59cb)`\n\n`2\u6c42\u8fde\u7eed\u5b57\u7b26\u4e32\u548c\u6ee1\u8db3\u4e00\u5b9a\u6761\u4ef6-->sum[j]-sum[i]`\n\n**[\u6613\u9519\u70b9]\u591a\u4f59\u94fe\u8868\u3001\u8bb0\u5f55\u7684\u95ee\u9898**\n**[\u6613\u9519\u70b9]sum\u6709n+1\u4e2a(\u8fd8\u67090)\n\nPAT1016 Phone Bills\n>\u5939\u903c\u9898:[a,b]!c\n```cpp\nfor(j=temp;st[j].time<=cal(c)&&j<st.size();++j)\n    if(st[j].status==0)sum++;\n    else sum--;\n```\n>\u5806\n```cpp\n//[f,l),[,Compare comp]\nvoid pop_heap(iterator first, iterator last);//\u5411\u4e0b\u8c03\u6574,\u539f\u5806\u9876->last-1,O(log(n))\nvoid push_heap(iterator first, iterator last);//\u5411\u4e0a\u8c03\u6574O(log(n))\nvoid make_heap(iterator first, iterator last);//\u5efa\u5806O(n)\nvoid sort_heap(iterator first, iterator last);//\u5efa\u5806\u540e\u6392\u5e8fO(nlog(n))\n```\n6.\u8fd0\u884c\u8d85\u65f6:\n- \u5faa\u73af\u5185\u5957\u4e86\u4e00\u4e2a\u5927\u51fd\u6570:\u5982\u5faa\u73af\u5185sort(>1000),\u6216\u662f\u4e00\u4e2a\u5927\u6570\u7ec4($10^5$)\u7684cin-->scanf\n- nontype to type:\u8bbe\u8ba1\u51fd\u6570\u662f\u4e0d\u8981\u4e00\u5473\u7528&\u5f15\u7528,\u5982\u679c\u4f20\u53c2\u662fnon-const(eg.3->int),\u4f1a\u62a5\u9519\n\n*Eg:i<strlen(s),\u6bcf\u6b21\u6c42\u957f\u5ea6*\n- \u5916\u5faa\u73af\u4e0e\u5185\u5faa\u73af\u6761\u4ef6\u5bf9\u6362\uff0c\u53ef\u4ee5\u51cf\u5c11\u91cd\u590d\n\n7.\u903b\u8f91\u9519\u8bef\n- for:scanf()\u5faa\u73af\u52a0\u4e86\u6c42sum\u6216\u8005\u5217\u8868\u95ee\u9898,\u4f46\u8fd8\u6ca1sort\u5462\n- int \u8f6c double,\u6ce8\u610f\u4e0d\u80fd\u76f4\u63a5return\n```cpp\ndouble function(){\n   double x;\n   if(type==1)x=0;\n   if(type==2)x=1;\n   else ...\n   return x;\n}\n```",
        "title": "STL,\u57fa\u7840\u6570\u5b66",
        "categories": [
            "[\u968f\u7b14\u5206\u7c7b]\u7b97\u6cd5",
            "[\u968f\u7b14\u5206\u7c7b]PAT"
        ],
        "enclosure": {
            "length": 0
        },
        "link": "https://www.cnblogs.com/chanceYu/p/12037269.html",
        "permalink": "https://www.cnblogs.com/chanceYu/p/12037269.html",
        "postid": "12037269",
        "source": {},
        "userid": "-2"
    },
    {
        "dateCreated": "20191213T20:53:00",
        "description": "`1.\u6811\u7684\u641c\u7d22--`\n\n>order traverse\n\n##### \u601d\u8def1:bfs(\u8981\u5efa\u6811\u7684\u6570\u636e\u7ed3\u6784)\n##### \u601d\u8def2:dfs(\u8981Node\u7ed3\u6784\u4f53)\n```cpp\nstruct sq {\n\tint index;\n\tint data;\n};\nvoid order(int i,int j) {\n\tif (node[i].lchild == -1 && node[i].rchild == -1) {\n\t\tin.push_back(i);\n\t\treturn;\n\t}\n\tif (node[i].lchild != -1) {\n\t\tlevel.push_back({2 * j,node[i].lchild});\n\t\torder(node[i].lchild,2 * j);\n\t}\n\tin.push_back(i);\n\tif (node[i].rchild != -1) {\n\t\tlevel.push_back({2 * j+1,node[i].rchild});\n\t\torder(node[i].rchild,2 * j+1);\n\t}\n\n}\nbool cmp(sq a,sq b) {\n\treturn a.index<b.index;\n}\n```\n>\u641c\u7b26\u5408\u8981\u6c42\u8def\u5f84(\u4e0d\u9700\u8981Node\u7ed3\u6784\u4f53)\n```cpp\nconst int maxn = 1010;\nvector<int> g[maxn];//\u5df2\u77e5\u7ed3\u70b9\u5173\u7cfb\nvoid dfs(int x, int dp) {//depth\u8fd0\u7528\n    path[depth] = w[x];\n    if (g[x].size() == 0) {\n        ll temp = 0;\n        for (int i = 0; i <= depth; i++) temp += path[i];\n        if (temp == s) {\n            for (int i = 0; i <= depth; i++) ans[len].push_back(path[i]);\n            len++;\n        }\n        return;\n    }\n    for (int i = 0; i < g[x].size(); i++) {\n        dfs(g[x][i], dp + 1);\n    }\n}\n```\n`2.\u7a7a\u95f4\u95ee\u9898`\n\n##### \u65b9\u6cd51:vector.resize(k)+vector\u672c\u8eab\u4e5f\u53ef\u4ee5\u7528\u4e0b\u6807(\u221a)\n##### \u65b9\u6cd52:int child[100]+int k=0;\n`3.\u67e5\u627evector\u4e2d\u67d0\u503c\u7684lower uper--PAT1043`\n\n\u8bd5\u6bd4\u8f83\u4ee5\u4e0b\u548cfor\u5faa\u73af+i--,\u4f1a\u6709for\u7b2c\u4e00\u503c\u9000\u51fa\u65f6\u591a\u51cf\u4e86\n\u82e5\u662f\u9012\u589e\u5e8f\u5217\uff0c\u4e0d\u5982\u76f4\u63a5\u627e\u6bd4\u4ed6\u5c0f\u7684\u4e0b\u4e00\u4e2a\uff0c\u6bd4\u4ed6\u5927\u7684\u4e0a\u4e00\u4e2a\n```cpp\nif(!isMirror) {\n\twhile(i <= tail && pre[root] > pre[i]) i++;\n\twhile(j > root && pre[root] <= pre[j]) j--;\n} else {\n\twhile(i <= tail && pre[root] <= pre[i]) i++;\n\twhile(j > root && pre[root] > pre[j]) j--;\n}\n```\n`4.Node\u5f62\u53c2\u95ee\u9898->\u6bb5\u9519\u8bef\u63a2\u8ba8`\n```cpp\nstruct Node {\n\tvector<int> child;\n\tdouble sp = 0;\n};\nvoid dfs(int x,int dp) {\n\tint i;\n\tif(v[x].child.size()!=0) {\n\t\tfor (i = 0; i<v[x].child.size(); ++i) \n\t\tif (dp+1 > pw.size()-1)\n\t\t\tpw.push_back(pow(r, dp+1));\n\t\t\tdfs(v[x].child[i],dp+1);\n\t} \n\telse sum += 1.0*v[x].sp*p*pw[dp];\n}\n```\n\u5982\u679c\u5c06dfs\u7b2c\u4e00\u4e2a\u53c2\u6570\u5199\u4e3aNode x\u4f1a\u7206\u7a7a\u95f4,\u66f4\u4e0d\u8c08\u5b58\u51e0\u4e2adouble\u4e86,\u76f4\u63a5\u7528\u8282\u70b9\u56fe\u6216\u8005\u5c42\u5206\u5e03\u56fevector<int> g[maxn];\n```cpp\nvoid dfs(int x, int depth) {\n    if (g[x].size() == 0) {\n        ans += (dat[x] * pow(1 + r, depth));\n        return;\n    }\n    for (int i = 0; i < g[x].size(); i++) {\n        dfs(g[x][i], depth + 1);\n    }\n}\n```\n**`\u6bb5\u9519\u8bef\u603b\u7ed3:`**\n\n>(1)\u8d8a\u754c\u8bbf\u95ee\n##### \u6570\u7ec4\u5f00\u5c0f\u4e86\u5bfc\u81f4\u6307\u9488\u6307\u5411\u4e86\u4e3a\u5f00\u8f9f\u7684\u6570\u7ec4\u533a\u57df\uff0c\u51fa\u73b0\u4e86\u8d8a\u754c\u8bbf\u95ee\u591a\u5c42for\u5faa\u73af\u4e2d\u5185\u5c42\u5faa\u73af\u672c\u6765\u6253\u7b97\u5199j\u6216\u8005k\uff0c\u5374\u56e0\u4e3a\u4e60\u60ef\u6216\u5fd8\u8bb0\u8bef\u5199\u6210\u4e86\u5916\u5c42\u5faa\u73af\u7684\u53d8\u91cfi\u6216j\uff0c\u5bfc\u81f4\u6570\u7ec4\u8bbf\u95eei\u6216j\u4e0b\u6807\u7684\u65f6\u5019\u53d1\u2f63\u4e86\u8d8a\u754c\n>(2)\u6808\u7a7a\u95f4\u548c\u5806\u7a7a\u95f4\n##### \u2f24\u6570\u7ec4\u5728main\u51fd\u6570\u2fa5\u2faf\u7684\u8bdd\u662f\u5b58\u50a8\u5728\u6808\u2fa5\uff0c\u2f7d\u6808\u7a7a\u95f4\u662f\u5728\u8fdb\u7a0b\u521b\u5efa\u65f6\u521d\u59cb\u5316\uff0c\u6709\u56fa\u5b9a\u7684\u2f24\u2f29\uff0c\u2f00\u822c\u4e3a\u2f0f\u2f17KB\uff0c\u6240\u4ee5\u592a\u2f24\u7684\u6570\u7ec4\u4f1a\u8017\u5149\u6808\u7a7a\u95f4\u3002\u2f7d\u5168\u5c40\u53d8\u91cf\u5360\u2f64\u7684\u5806\u7a7a\u95f4\uff0c\u5806\u7a7a\u95f4\u4e2d\u7684\u5185\u5b58\u662f\u6309\u9700\u5206\u914d\uff0c\u2f83\u7531\u589e\u2ed3\u7684\uff0c\u53ef\u4ee5\u2fae\u5e38\u2f24\uff0c\u2f50\u598232\u4f4d\u7684\u7cfb\u7edf\u4e2d\u53ef\u4ee5\u2f24\u52304GB\u3002\u5c06\u2f24\u6570\u7ec4\u653e\u5728\u5168\u5c40\u53d8\u91cf\u4e2d\u80fd\u907f\u514d\u6808\u6ea2\u51fa\n\n`5.\u5e76\u67e5\u96c6`\n```cpp\nint findf(int v){\n    if(v==father[v])//\u6ce8\u610f\u70b91\n        return v;\n        else\n        {\n            int f = findf(father[v]);//\u6ce8\u610f\u70b92\uff0c\u4e0d\u7136\u90a3\u65e0\u6cd5\u7ed3\u675f\n            father[v] = f;\n            return f;\n        }     \n}\nvoid uni(int a,int b){\n    int fa = findf(a);\n    int fb = findf(b);\n    if(fa!=fb)\n        father[fa] = fb;\n}\n```\n`6.\u5b57\u7b26\u4e32\u6a21\u677f`\n```cpp\nint str2num(char *a)\n{\n    return 26 * 26 * (a[0]-'A') + 26 * (a[1]-'A') + (a[2]-'A');\n}\nstring num2str(int num){\n    string a(3,0);\n    a[0] = num / (26 * 26)+'A';\n    a[1] = num / 26 % 26 + 'A';\n    a[2] = num % 26 + 'A';\n    return a;\n}\n```",
        "title": "\u6811",
        "categories": [
            "[\u968f\u7b14\u5206\u7c7b]PAT",
            "[\u968f\u7b14\u5206\u7c7b]\u7b97\u6cd5"
        ],
        "enclosure": {
            "length": 0
        },
        "link": "https://www.cnblogs.com/chanceYu/p/12037248.html",
        "permalink": "https://www.cnblogs.com/chanceYu/p/12037248.html",
        "postid": "12037248",
        "source": {},
        "userid": "-2"
    },
    {
        "dateCreated": "20191213T20:44:00",
        "description": "1.\u6570\u8fde\u901a\u5206\u91cf(\u5e76\u67e5\u96c6)\n\n*PAT1013 Battle Over Cities*\n##### `\u5f53\u5220\u9664\u5176\u4e2d\u4e00\u4e2a\u9876\u70b9\u53ca\u5176\u76f8\u5173\u7684\u8fb9\u4e4b\u540e\uff0c\u8ba1\u7b97\u51fa\u5269\u4e0b\u7684\u56fe\u7684\u8fde\u901a\u5206\u91cf\uff0c\u90a3\u4e48\u589e\u52a0\u7684\u8fb9\u5c31\u5e94\u8be5\u662f\u6c42\u51fa\u7684\u8fde\u901a\u5206\u91cf-1`\n>\u6cd51:\u6bcf\u6b21dfs\u524d\u5224\u65advisit[i]==0;\n```cpp\nvoid dfs(int s) {\n    visit[s] = 1;\n    for(int i = 1; i<=n; ++i)\n\tif(g[s][i]==1&&visit[i]==0)dfs(i);\n}\n...main:\nfor (i = 0; i < k; ++i) {\n    sum = 0;cin >> m;\n    fill(visit.begin(),visit.end(),0);\n    visit[m] = 1;\n    for (j = 1; j<=n; ++j)\n        if (visit[j] == 0){dfs(j);sum++;}\n    printf(\"%d\\n\", sum-1);\n}\n```\n>\u6cd52:\u6570\u6839\u7ed3\u70b9father[v]==v;\n```cpp\nwhile(K--){\n    int v;int num=0;\n    scanf(\"%d\",&v);\n    iota(father,father+N+1,0);//\u521d\u59cb\u5316\u5e76\u67e5\u96c6\n    for(int i=1;i<N+1;++i)\n        if(i!=v)for(int j:graph[i])\n            if(j!=v)uni(i,j);\n    for(int i=1;i<=N;++i)\n        if(i!=v&&father[i]==i)\n            ++num;\n    printf(\"%d\\n\",num-1);\n}\n```\n*Leetcode947*\n##### \u5728\u4e8c\u7ef4\u5e73\u9762\u4e0a\u5c06\u77f3\u5934\u653e\u7f6e\u5728\u4e00\u4e9b\u6574\u6570\u5750\u6807\u70b9\u4e0a\u3002\u6bcf\u4e2a\u5750\u6807\u70b9\u4e0a\u6700\u591a\u53ea\u80fd\u6709\u4e00\u5757\u77f3\u5934\u3002\u73b0\u5728\uff0c\u4e00\u4e2amove\u5c06\u4f1a\u79fb\u9664\u4e0e\u7f51\u683c\u4e0a\u7684\u53e6\u4e00\u5757\u77f3\u5934\u5171\u4eab\u4e00\u5217\u6216\u4e00\u884c\u7684\u4e00\u4e2a\u77f3\u5934\u3002\n```cpp\nint removeStones(vector<vector<int>>& stones) {\n    if(stones.size() <= 1) return 0;\n    int res = stones.size(), len = stones.size();\n    vector<int> p(len,-1);\n    for(int i =0;i < len;i++){\n        for(int j = i+1;j < len;j++){\n            if(stones[j][0] == stones[i][0] || stones[j][1] == stones[i][1])\n                u(p, i, j);\n        }\n    }\n    for(auto e : p){\n        if(e == -1) res--;\n    }\n    return res;\n}\n```\n2.\u6709\u5173\u662f\u5bf9\u8fb9dfs\u8fd8\u662f\u70b9dfs\n\n*PAT1034*\n>##### \u7ed9\u51fa\u591a\u4e2a\u4eba\u4e4b\u95f4\u7684\u901a\u8bdd\u957f\u5ea6\uff0c\u6309\u7167\u8fd9\u4e9b\u901a\u8bdd\u5c06\u4ed6\u4eec\u5206\u6210\u82e5\u5e72\u4e2a\u7ec4\uff0c\u5404\u4e2a\u7ec4\u7684\u603b\u6743\u503c\u662f\u8be5\u7ec4\u5185\u6240\u6709\u901a\u8bdd\u957f\u5ea6\u4e4b\u548c\uff0c\u6bcf\u4e2a\u4eba\u7684\u6743\u503c\u662f\u5176\u53c2\u4e0e\u7684\u6240\u6709\u901a\u8bdd\u957f\u5ea6\u4e4b\u548c\u3002\u6c42\u7ec4\u6570\u548c\u7ec4\u5185\u901a\u8bdd\u6700\u957f\u7684\n\u6bcf\u4e2a\u70b9\u81f3\u5c11\u6709\u4e00\u4e2a\u8fde\u7ebf\uff0c\u6545\u53ef\u4ee5\u5bf9\u8fb9\u641c`\u6570\u91cf\u5173\u7cfb\u7684\u8fd0\u7528:\u8fb9\u6743\u548c=\u70b9\u6743\u548c/2`\n\n*\u4e4b\u540e\u7684\u64cd\u4f5c--PAT2019\u66257-3 Telefraud Detection*\n>##### \u7535\u4fe1\u8bc8\u9a97\u5224\u65ad\u5acc\u7591\u72af,\u82e5\u72af\u4eba\u4e4b\u95f4\u901a\u8fc7\u8bdd\u8bf4\u660e\u662f\u4e00\u4e2a\u56e2\u4f19\n```cpp\nfor(i=1;i<=n;++i)\n    if(sus[i]==1)\n        for(j=i+1;j<=n;++j)\n            if(sus[j]==1&&g[i][j]>0&&g[j][i]>0)uni(i,j);\nw=1;\nfor(i=1;i<=n;++i){\n    if(sus[i]==1){\n        if(mp[findf(i)]==0){\n            mp[findf(i)]=w;\n            gang[w].push_back(i);\n            w++;\n        }//\u5c06\u8054\u901a\u5206\u91cf\u8f6c\u6362\u4e3agang\n        else gang[mp[findf(i)]].push_back(i);\n    }\n}\n```\n*PAT1021*\n>##### \u7ed9\u5b9aN\u4e2a\u7ed3\u70b9\u548cN-1\u6761\u8fb9\uff0c\u95ee\u80fd\u5426\u6784\u6210\u4e00\u68f5\u6811\uff0c\u5982\u679c\u80fd\uff0c\u5219\u8f93\u51fa\u4f5c\u4e3a\u6811\u7684\u6839\u8282\u70b9\u65f6\u4f7f\u5f97\u6574\u68f5\u6811\u6df1\u5ea6\u6700\u5927\u7684\u7ed3\u70b9\uff0c\u5982\u679c\u4e0d\u80fd\uff0c\u8f93\u51fa\u8fd9\u4e2a\u56fe\u4e2d\u6709\u51e0\u4e2a\u8fde\u901a\u5206\u91cf\u3002\n\u80fd\u5426\u6784\u6210\u6811\uff0c\u8981\u4e48\u6709>1\u4e2a\u8fde\u901a\u5206\u91cf,\u8981\u4e48\u6709\u73af\n\n3.Hamiltonian Cycle\n>##### (1)\u662f\u5426\u662fN+1\u4e2a\u70b9\u3002                         (2)\u9664\u8d77\u70b9\u5916\uff0c\u6bcf\u4e2a\u70b9\u662f\u5426\u53ea\u51fa\u73b0\u4e861\u6b21                    (3)\u7ecf\u8fc7\u7684\u8fb9\u662f\u5426\u5b58\u5728                                  (4)\u8d77\u70b9\u662f\u5426\u7b49\u4e8e\u7ec8\u70b9\n`\u6ce8\u610f\u5254\u9664\u91cd\u590d\u70b9\u65f6\u8981\u7528set(\u5f80\u5f80\u9690\u542b)`\n```cpp\nvoid check(int index) {\n    int sum = 0, cnt, flag = 1;\n    scanf(\"%d\", &cnt);\n    set<int> s;\n    vector<int> v(cnt);\n    for (int i = 0; i < cnt; i++) {\n        scanf(\"%d\", &v[i]);\n        s.insert(v[i]);\n    }\n    for (int i = 0; i < cnt - 1; i++) {\n        if(e[v[i]][v[i+1]] == 0) flag = 0;//3\n        sum += e[v[i]][v[i+1]];\n    }\n    if (flag == 0)\n    printf(\"Path %d: NA (Not a TS cycle)\\n\", index);\n    else if(v[0]!=v[cnt-1]||s.size()!=n)//4,2\n    printf(\"Path %d: %d (Not a TS cycle)\\n\", index, sum);\n    else if(cnt != n + 1)printf(\"Path %d: %d (TS cycle)\\n\", index, sum);//1\n    else printf(\"Path %d: %d (TS simple cycle)\\n\", index, sum);\n}\n```\n\n4.dfs\u7ed3\u6784\u603b\u7ed3\n```cpp\nvoid dfs(int x){\n    temp.push_back(x);\n    if (pre[x][0] == -1){\n        ......\n    }\n    for(int i=0;i<pre[x].size();i++){\n        dfs(pre[x][i]);\n    }\n    temp.pop_back();\n}\n```",
        "title": "\u56fe",
        "categories": [
            "[\u968f\u7b14\u5206\u7c7b]PAT",
            "[\u968f\u7b14\u5206\u7c7b]\u7b97\u6cd5"
        ],
        "enclosure": {
            "length": 0
        },
        "link": "https://www.cnblogs.com/chanceYu/p/12037212.html",
        "permalink": "https://www.cnblogs.com/chanceYu/p/12037212.html",
        "postid": "12037212",
        "source": {},
        "userid": "-2"
    },
    {
        "dateCreated": "20191213T20:43:00",
        "description": "1.\u6570\u5b66\u95ee\u9898\n\n(1)\u7d20\u6570\n##### \u7b97\u672f\u57fa\u672c\u5b9a\u7406:\u82e5$a\\in Z$,$a\\gt 1$,\u5219\u6709$a=p_1p_2\\cdots p_n$,\u5176\u4e2d$p_i$\u4e3a\u7d20\u6570\n>##### \u8bc1\u660e:\u5047\u5b9a\u5b9a\u7406\u5bf9\u6240\u6709\u5c0f\u4e8ea\u7684\u6b63\u6574\u6570\u5747\u6210\u7acb \u82e5a\u4e3a\u7d20\u6570,\u5219\u7ed3\u8bba\u663e\u7136\u6210\u7acb \u82e5a\u4e3a\u5408\u6570,$a=bc$,\u5176\u4e2d$1\\lt b,c\\lt a$\u7531\u5f52\u7eb3\u5047\u8bbe$b=p_1p_2\\cdots p_k,c=p_{k+1}p_{k+2}\\cdots p_n$\n\n```cpp\nfor(int i = 2; i <= n; i++)\n{\n\tif(!vis[i])\n\tprime[cnt++] = i;\n\tfor(int j = 0; j<cnt && i*prime[j]<=n; j++)\n\t{\n\t\tvis[i*prime[j]] = 1;\n\t\tif(i % prime[j] == 0) break;\n\t}\n}\n```\n##### \u5224\u65ad\u7d20\u6570\n>##### `\u9677\u9631:1\u7684\u7279\u6b8a\u5904\u7406(\u6781\u6613\u9519)`\n```cpp\nbool judge(int x){\n\tif(x<2)return 0;\n    for(int i=2;i<=sqrt(x);++i){//9\n        if(x%i==0)return 0;\n    }\n    return 1;\n}\n```\n(2)gcd\n```cpp\nlong long gcd(long long a,long long b){return b==0?a:gcd(b,a%b);}//\u539f\u6765a>b\u73b0\u8c03\u6362\n```\n(3)\u56de\u6587\u6570\n```cpp\nfor(int i = 0; i < index / 2; i++) {\n\tif(arr[i] != arr[index-i-1]) \n\t{         \n\t\tprintf(\"No\\n\");            \n\t\tflag = 1;break;        \n\t}    \n}if(!flag)printf(\"Yes\\n\");\n```\n3.\u6570\u636e\u7c7b\u578b\u8303\u56f4\n<table>\n<thead>\n<tr>\n<th>\u6570\u636e\u7c7b\u578b</th>\n<th>\u752810\u8868\u793a</th>\n<th>\u75282\u8868\u793a</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>unsigned int</td>\n<td><img class=\"math-inline\" src=\"https://math.jianshu.com/math?formula=0%2C%204%C3%9710%5E%7B9%7D\" alt=\"0, 4\u00d710^{9}\" mathimg=\"1\"0, 4\u00d710^9></td>\n<td><img class=\"math-inline\" src=\"https://math.jianshu.com/math?formula=0%2C%202%5E%7B32%7D-1\" alt=\"0, 2^{32}-1\" mathimg=\"1\"></td>\n</tr>\n<tr>\n<td>int</td>\n<td><img class=\"math-inline\" src=\"https://math.jianshu.com/math?formula=-2%C3%9710%5E%7B9%7D%2C%202%C3%9710%5E%7B9%7D\" alt=\"-2\u00d710^{9}, 2\u00d710^{9}\" mathimg=\"1\"></td>\n<td><img class=\"math-inline\" src=\"https://math.jianshu.com/math?formula=-2%5E%7B31%7D%2C%202%5E%7B31%7D-1\" alt=\"-2^{31}, 2^{31}-1\" mathimg=\"1\"></td>\n</tr>\n<tr>\n<td>unsigned long</td>\n<td><img class=\"math-inline\" src=\"https://math.jianshu.com/math?formula=0%2C%204%C3%9710%5E%7B9%7D\" alt=\"0, 4\u00d710^{9}\" mathimg=\"1\"></td>\n<td><img class=\"math-inline\" src=\"https://math.jianshu.com/math?formula=0%2C%202%5E%7B32%7D-1\" alt=\"0, 2^{32}-1\" mathimg=\"1\"></td>\n</tr>\n<tr>\n<td>long</td>\n<td><img class=\"math-inline\" src=\"https://math.jianshu.com/math?formula=-2%C3%9710%5E%7B10%7D%2C%202%C3%9710%5E%7B10%7D\" alt=\"-2\u00d710^{10}, 2\u00d710^{10}\" mathimg=\"1\"></td>\n<td><img class=\"math-inline\" src=\"https://math.jianshu.com/math?formula=-2%5E%7B31%7D%2C%202%5E%7B31%7D-1\" alt=\"-2^{31}, 2^{31}-1\" mathimg=\"1\"></td>\n</tr>\n<tr>\n<td>long long</td>\n<td><img class=\"math-inline\" src=\"https://math.jianshu.com/math?formula=0%2C%209%C3%9710%5E%7B18%7D\" alt=\"0, 9\u00d710^{18}\" mathimg=\"1\"></td>\n<td><img class=\"math-inline\" src=\"https://math.jianshu.com/math?formula=-2%5E%7B63%7D%2C%202%5E%7B63%7D-1\" alt=\"-2^{63}, 2^{63}-1\" mathimg=\"1\"></td>\n</tr>\n<tr>\n<td>unsigned long long</td>\n<td><img class=\"math-inline\" src=\"https://math.jianshu.com/math?formula=0%2C%2010%5E%7B19%7D\" alt=\"0, 10^{19}\" mathimg=\"1\"></td>\n<td><img class=\"math-inline\" src=\"https://math.jianshu.com/math?formula=0%2C%202%5E%7B64%7D-1\" alt=\"0, 2^{64}-1\" mathimg=\"1\"></td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>\u6570\u636e\u7c7b\u578b</th>\n<th>\u6bd4\u7279\u4f4d\u6570</th>\n<th>\u6709\u6548\u6570\u5b57</th>\n<th>\u752810\u8868\u793a</th>\n<th>\u75282\u8868\u793a</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>float</td>\n<td>32</td>\n<td>6~7</td>\n<td><img class=\"math-inline\" src=\"https://math.jianshu.com/math?formula=-3.4*10%5E%7B38%7D%EF%BD%9E%2B3.4*10%5E%7B38%7D\" alt=\"-3.4*10^{38}\uff5e+3.4*10^{38}\" mathimg=\"1\"></td>\n<td><img class=\"math-inline\" src=\"https://math.jianshu.com/math?formula=-2%5E%7B128%7D%20~%20%2B2%5E%7B128%7D\" alt=\"-2^{128} ~ +2^{128}\" mathimg=\"1\"></td>\n</tr>\n<tr>\n<td>double</td>\n<td>64</td>\n<td>15~16</td>\n<td><img class=\"math-inline\" src=\"https://math.jianshu.com/math?formula=-1.7*10%5E%7B-308%7D~1.7*10%5E%7B308%7D\" alt=\"-1.7*10^{-308}~1.7*10^{308}\" mathimg=\"1\"></td>\n<td>\u2014\u2014</td>\n</tr>\n<tr>\n<td>long double</td>\n<td>128</td>\n<td>18~19</td>\n<td><img class=\"math-inline\" src=\"https://math.jianshu.com/math?formula=-1.2*10%5E%7B-4932%7D~1.2*10%5E%7B4932%7D\" alt=\"-1.2*10^{-4932}~1.2*10^{4932}\" mathimg=\"1\"></td>\n<td>\u2014\u2014</td>\n</tr>\n</tbody>\n</table>\n\n---\n## \u6c42\u89e3\u6280\u5de7\n`\u601d\u8def:\u904d\u5386\u8303\u56f4\u5185\u5168\u90e8\u6570\u5b57,\u4f9d\u636e\u9996+\u5c3e/\u9996+\u95f4\u9694\u904d\u5386`\n\n1.\u4e8c\u5206\u6cd5upper_bound,lower_bound\u7684\u8fd0\u7528\n\n2.PAT\u9898\uff0c\u5229\u7528\u6b21\u5e8f\n```cpp\nfor (int i = 0; i < len; i++) {\n\tif (s[i] == 'T')countt++;\n}\nfor (int i = 0; i < len; i++) {\n\tif (s[i] == 'P')countp++;\n\tif (s[i] == 'T')countt--;\n\tif (s[i] == 'A')result = (result + (countp * countt) % 1000000007) % 1000000007;\n}\n```\n3.\u6570\u5b66\u5f62\u5f0f\u9898\u6ce8\u610f\u5bf9\u6570\u5b57\u7684\u76f4\u63a5\u5229\u7528\uff0c\u5c11\u7528\u5b57\u7b26\u4e32\u7279\u6027",
        "title": "\u66b4\u529b\u6c42\u89e3/\u6570\u5b66\u95ee\u9898",
        "categories": [
            "[\u968f\u7b14\u5206\u7c7b]PAT",
            "[\u968f\u7b14\u5206\u7c7b]\u7b97\u6cd5"
        ],
        "enclosure": {
            "length": 0
        },
        "link": "https://www.cnblogs.com/chanceYu/p/12037202.html",
        "permalink": "https://www.cnblogs.com/chanceYu/p/12037202.html",
        "postid": "12037202",
        "source": {},
        "userid": "-2"
    },
    {
        "dateCreated": "20191213T17:28:00",
        "description": "PAT\u6682\u65f6\u6ca1\u6709\u9898\u76ee\u7ec3\u4e60\u62d3\u6251\u6392\u5e8f\uff0c\u4ee5\u4e0b\u662fLeetcode\u9898\u76ee\n#### There are a total of n courses you have to take, labeled from 0 to n-1.Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]\n#### Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?\n#### Example 1:\n>Input: 2, [[1,0]] \nOutput: true\nExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.\n#### Example 2:\n>Input: 2, [[1,0],[0,1]]\nOutput: false\nExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n\n\u601d\u8def1:\u961f\u5217\u65b9\u6cd5\n```cpp\nbool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n    int m=prerequisites.size(),i,x=0;\n    vector<vector<int>>g(numCourses);\n    vector<int>in(numCourses,0);\n    for(i=0;i<m;++i){\n        int c1=prerequisites[i][0],c2=prerequisites[i][1];\n        if(c1>=0&&c2>=0&&c1<numCourses&&c2<numCourses){\n            g[c2].push_back(c1);\n            in[c1]++;\n        }\n    }\n    queue<int>q;\n    for(i=0;i<numCourses;++i)if(in[i]==0)q.push(i);\n    while(!q.empty()){\n        int u=q.front();\n        q.pop();x++;\n        for(i=0;i<g[u].size();++i){\n            in[g[u][i]]--;\n            if(in[g[u][i]]==0)q.push(g[u][i]);\n        }\n    }\n    if(x==numCourses)return true;\n    else return false;\n```\n\u601d\u8def2:dfs\u5224\u65adDAG(Directed Acyclic Gragh)\n```cpp\nvector<vector<int>>g;vector<int>visit;\nbool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n    int m=prerequisites.size(),i,x=0;\n    g.resize(numCourses);\n    visit.resize(numCourses,0);\n    for(i=0;i<m;++i){\n        int c1=prerequisites[i][0],c2=prerequisites[i][1];\n        if(c1>=0&&c2>=0&&c1<numCourses&&c2<numCourses)g[c2].push_back(c1);\n    }\n    for(i=0;i<numCourses;++i)\n        if(!visit[i]&&!dfs(i,x))return false;\n    if(x==numCourses)return true;\n    else return false;\n}\nbool dfs(int& u,int& dp){\n    visit[u]=-1;\n    for(int i=0;i<g[u].size();++i){\n        if(visit[g[u][i]]==-1)return 0;\n        else if(!visit[g[u][i]]&&!dfs(g[u][i],dp))return 0;\n    }\n    visit[u]=1;dp++;return 1;\n}\t\n ```",
        "title": "Leetcode207. Course Schedule",
        "categories": [
            "[\u968f\u7b14\u5206\u7c7b]Leetcode"
        ],
        "enclosure": {
            "length": 0
        },
        "link": "https://www.cnblogs.com/chanceYu/p/12036364.html",
        "permalink": "https://www.cnblogs.com/chanceYu/p/12036364.html",
        "postid": "12036364",
        "source": {},
        "userid": "-2"
    }
]