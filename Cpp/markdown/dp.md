## 动态规划
刷表法--考虑每个状态影响到的状态
填表法--考虑每个状态的依赖
状态方向：has/remain
*完全背包问题*
>总体积不超过T的情况下最大重量dp[T]=dp[T-v[i]]+w[i]/
总体积剩余T时最大重量dp[T]=dp[T-v[i]]+w[i]/
~~总体积达到T后还剩余的最大重量dp[T]=dp[T+v[i]]+w[i]~~


#### `这时可以综合考虑刷表/填表法需要啊考虑的因素区别+思考方向是否习惯,另一方面可根据搜索元素的顺序调整内外循环顺序,如下`
```cpp
for(i=0;i<m;++i)for(j=t-v[i].g;j>=0;--j)
dp[j]=max(dp[j],dp[j+g[i]]+w[i]);
```
>小结:
(1)最后的处理
如果聚零为整(不断累加背包，看影响后面的价值)，最后要求min/max_element-->
如果化整为零(最大容量减少),最后只需求端点值
(2)涉及求字典序(或涉及dp的序号获取)
法1:去掉不可达结点，初始化为-inf(max)inf(min)
法2:加入实际has数组
